/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   prompt_user_helper.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/08 15:51:26 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/12 15:09:49 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

/* Trim buffer [0..len) whitespace and return a malloc'd string or NULL. */
char	*trim_and_dup(const char *buf, size_t len)
{
	size_t	start;
	size_t	end;
	char	*out;

	start = 0;
	end = len;
	if (!buf || len == 0)
		return (NULL);
	while (start < end && (buf[start] == ' ' || buf[start] == '\t'
			|| buf[start] == '\r' || buf[start] == '\n'))
		start++;
	while (end > start && (buf[end - 1] == '\n' || buf[end - 1] == '\r'
			|| buf[end - 1] == ' ' || buf[end - 1] == '\t'))
		end--;
	if (start >= end)
		return (NULL);
	out = malloc(end - start + 1);
	if (!out)
		return (NULL);
	ft_memcpy(out, buf + start, end - start);
	out[end - start] = '\0';
	return (out);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   prompt_build.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/08 15:51:26 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/12 15:09:49 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

/* calcula la suma de longitude
deevuelve 0 si count <= 0
 */
static size_t	parts_total_len(const char **parts, int count)
{
	size_t	total;
	size_t	i;

	if (count <= 0)
		return (0);
	total = 0;
	i = 0;
	while (i < (size_t)count)
	{
		total += ft_strlen(parts[i]);
		i++;
	}
	return (total);
}

/* copiamoos todas las partes en el buffer 'out' necsiita espacio suficiente
al final pone '\0'
 */
static void	parts_copy_to_buf(const char **parts, int count, char *out)
{
	size_t	pos;
	size_t	i;
	size_t	len;

	pos = 0;
	i = 0;
	while (i < (size_t)count)
	{
		len = ft_strlen(parts[i]);
		if (len > 0)
		{
			ft_memcpy(out + pos, parts[i], len);
			pos += len;
		}
		i++;
	}
	out[pos] = '\0';
}

/* une count partes en una unica cadeena alocada una vez
devuelve heap (caller free) o null en fallo
 */
char	*join_parts(const char **parts, int count)
{
	size_t	total;
	char	*out;

	if (count <= 0)
		return (ft_strdup(""));
	total = parts_total_len(parts, count);
	out = malloc(total + 1);
	if (!out)
		return (NULL);
	parts_copy_to_buf(parts, count, out);
	return (out);
}
//buclee para ir uniendo todas las partes

static int	prompt_build_parts(t_data *data, char **userhost_out,
	char **shortcwd_out)
{
	char	*userhost;
	char	*shortcwd;

	userhost = get_user_host();
	shortcwd = get_short_cwd(data);
	if (!userhost)
		userhost = ft_strdup("?");
	if (!shortcwd)
		shortcwd = ft_strdup("?");
	if (!userhost || !shortcwd)
	{
		free(userhost);
		free(shortcwd);
		return (-1);
	}
	*userhost_out = userhost;
	*shortcwd_out = shortcwd;
	return (0);
}

char	*build_prompt(t_data *data)
{
	char		*userhost;
	char		*shortcwd;
	const char	*parts[5];
	char		*res;

	if (prompt_build_parts(data, &userhost, &shortcwd) == -1)
		return (NULL);

	parts[0] = userhost;
	parts[1] = ":";
	parts[2] = shortcwd;
	parts[3] = "$> ";
	parts[4] = NULL;

	res = join_parts(parts, 4);
	free(userhost);
	free(shortcwd);
	return (res);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   prompt_user.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/08 15:51:26 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/12 15:09:49 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"
#define HOST_READ_MAX 256

/* Read up to HOST_READ_MAX-1 bytes from path and return trimmed first-line. */
static char	*read_file_first_line(const char *path)
{
	int		fd;
	ssize_t	n;
	char	buf[HOST_READ_MAX];

	if (!path)
		return (NULL);
	fd = open(path, O_RDONLY);
	if (fd < 0)
		return (NULL);
	n = read(fd, buf, sizeof(buf) - 1);
	close(fd);
	if (n <= 0)
		return (NULL);
	buf[n] = '\0';
	return (trim_and_dup(buf, (size_t)n));
}

/* Duplicate env value or return NULL. */
static char	*dup_env_var(const char *primary, const char *secondary)
{
	const char	*value;

	if (!primary)
		return (NULL);
	value = getenv(primary);
	if (!value && secondary)
		value = getenv(secondary);
	if (!value)
		return (NULL);
	return (ft_strdup(value));
}

/* Return malloc'd username or "?" (caller frees). */
static char	*get_user_from_env(void)
{
	char	*user;

	user = dup_env_var("USER", "LOGNAME");
	if (!user)
		user = ft_strdup("?");
	return (user);
}

/* Return malloc'd hostname or "?" (caller frees). Tries env then files. */
static char	*get_host_from_env_or_files(void)
{
	char	*host;

	host = dup_env_var("HOSTNAME", "HOST");
	if (host)
		return (host);
	host = read_file_first_line("/etc/hostname");
	if (host)
		return (host);
	host = read_file_first_line("/proc/sys/kernel/hostname");
	if (host)
		return (host);
	return (ft_strdup("?"));
}

/*returns "user@host" malloc'd (caller must free) or NULL on alloc err */
char	*get_user_host(void)
{
	char	*user;
	char	*host;
	char	*tmp;
	char	*out;

	user = get_user_from_env();
	host = get_host_from_env_or_files();
	if (!user || !host)
	{
		free(user);
		free(host);
		return (NULL);
	}
	tmp = ft_strjoin(user, "@");
	if (!tmp)
	{
		free(user);
		free(host);
		return (NULL);
	}
	out = ft_strjoin(tmp, host);
	free(tmp);
	free(user);
	free(host);
	return (out);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   prompt_cwd.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/08 15:51:26 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/12 15:09:49 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

static char	*get_cwd_or_null(void)
{
	char	*cwd;

	cwd = getcwd(NULL, 0);
	if (!cwd)
		return (NULL);
	return (cwd);
}

/* 
	si cwd es nuull devuelve una cadena vacia ("")
	si no hay homee o cwd no comienza por HOME devuelve una copia delcwd
	si cwd es = al home devuelve ~
	si cwd estaa dentro del HOME devuelve ~ seguido del rest
 */
static char	*replace_home_prefix(const char *cwd, const char *home)
{
	size_t	home_len;

	if (!home || !cwd)
	{
		if (!cwd)
			return (ft_strdup(""));
		return (ft_strdup(cwd));
	}
	home_len = ft_strlen(home);
	if (ft_strncmp(cwd, home, home_len) != 0)
		return (ft_strdup(cwd));
	if (cwd[home_len] == '\0')
		return (ft_strdup("~"));
	return (ft_strjoin("~", cwd + home_len));
}

char	*get_short_cwd(t_data *data)
{
	char		*cwd;
	const char	*home;
	char		*res;

	cwd = get_cwd_or_null();
	if (!cwd)
		return (ft_strdup("?"));
	home = get_var_from_envp(data->envp, "HOME");
	if (!home)
		return (cwd);
	res = replace_home_prefix(cwd, home);
	free(cwd);
	return (res);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/03 14:58:53 by jadelgad          #+#    #+#             */
/*   Updated: 2026/02/11 14:23:35 by alemonto         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

static void	print_banner(void)
{
	printf("\n");
	printf(C);
	printf("         ██╗       ██╗       ███╗   ███╗    \n");
	printf("         ██║       ██║       ████╗ ████║    \n");
	printf("         ██║    ████████╗    ██╔████╔██║    \n");
	printf("    ██   ██║    ██╔═██╔═╝    ██║╚██╔╝██║    \n");
	printf("    ╚█████╔╝    ██████║      ██║ ╚═╝ ██║    \n");
	printf("     ╚════╝     ╚═════╝      ╚═╝     ╚═╝    \n");
	printf("                                             \n");
	printf("    ███████╗██╗  ██╗███████╗██╗     ██╗     \n");
	printf("    ██╔════╝██║  ██║██╔════╝██║     ██║     \n");
	printf("    ███████╗███████║█████╗  ██║     ██║     \n");
	printf("    ╚════██║██╔══██║██╔══╝  ██║     ██║     \n");
	printf("    ███████║██║  ██║███████╗███████╗███████╗\n");
	printf("    ╚══════╝╚═╝  ╚═╝╚══════╝╚══════╝╚══════╝\n");
	printf("                                             \n");
	printf(RST"\n");
}

static void	execute_logic(char *line, t_data *data)
{
	t_token	*tokens;
	t_token	*head;
	t_ast	*tree;

	tokens = tokenizer(line, data->last_status, data);
	if (!tokens)
		return ;
	head = tokens;
	tree = parser(&tokens);
	if (!tree && g_signal_received == SIGINT)
	{
		data->last_status = 130;
		g_signal_received = 0;
	}
	else if (tree)
	{
		data->last_status = exec_ast(tree, data);
		ast_free(tree);
	}
	else
		data->last_status = 2;
	free_tokens(head);
}

static void	run_non_interactive(t_data *data)
{
	char	*line;
	int		len;

	while (data->running == 0)
	{
		line = get_next_line(STDIN_FILENO);
		if (!line)
			break ;
		if (line[0] == '\n')
		{
			free(line);
			continue ;
		}
		len = ft_strlen(line);
		if (len > 0 && line[len - 1] == '\n')
			line[len - 1] = '\0';
		execute_logic(line, data);
		free(line);
	}
}

static void	run_interactive(t_data *data)
{
	char	*line;

	print_banner();
	setup_signals();
	while (data->running == 0)
	{
		line = get_input_line(data);
		if (handle_signal_interrupt(data, line))
			continue ;
		if (line == NULL)
		{
			write(1, "exit\n", 5);
			break ;
		}
		if (line[0] != '\0')
		{
			add_history(line);
			signal(SIGINT, SIG_IGN);
			execute_logic(line, data);
			setup_signals();
		}
		free(line);
	}
}

int	main(int ac, char **av, char **envp)
{
	t_data	data;

	(void)ac;
	(void)av;
	ft_memset(&data, 0, sizeof(t_data));
	data.envp = dup_env(envp);
	rl_catch_signals = 0;
	g_signal_received = 0;
	read_history(".nanoshell_history");
	if (isatty(STDIN_FILENO))
		run_interactive(&data);
	else
		run_non_interactive(&data);
	write_history(".nanoshell_history");
	rl_clear_history();
	free_env(data.envp);
	return (data.last_status);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelona.co  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/04 15:21:44 by jadelgad          #+#    #+#             */
/*   Updated: 2026/02/04 15:21:48 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

void	set_parser_error(t_parser_context *ctx,
		const char *message, t_token *token)
{
	if (ctx->error_status)
		return ;
	ctx->error_status = 1;
	ctx->error_message = message;
	ctx->error_token = token;
	ast_parser_error(ctx->error_message, token);
}

void	ctx_init(t_parser_context *ctx)
{
	ctx->error_status = 0;
	ctx->error_message = NULL;
	ctx->error_token = NULL;
}

t_ast	*parser(t_token **ptokens)
{
	t_parser_context	ctx;
	t_ast				*tree;

	ctx_init(&ctx);
	tree = parser_logical(ptokens, &ctx);
	if (ctx.error_status)
	{
		if (tree)
			ast_free(tree);
		return (NULL);
	}
	if (*ptokens != NULL)
	{
		set_parser_error(&ctx, "unexpected extra input", *ptokens);
		if (tree)
			ast_free(tree);
		return (NULL);
	}
	return (tree);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_ifs.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelona.co  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/04 15:21:44 by jadelgad          #+#    #+#             */
/*   Updated: 2026/02/04 15:21:48 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

// IFS = espacio, tab, newline
static int	is_ifs(char c)
{
	return (c == ' ' || c == '\t' || c == '\n');
}

static void	*safe_substr(const char *s, int start, int end)
{
	void	*ptr;

	ptr = ft_substr(s, start, end);
	if (!ptr)
	{
		perror("ft_substr failed");
		exit(EXIT_FAILURE);
	}
	return (ptr);
}

void	free_split(char **split)
{
	int	i;

	if (!split)
		return ;
	i = 0;
	while (split[i])
	{
		free(split[i]);
		i++;
	}
	free(split);
}

char	**split_by_ifs(const char *s)
{
	char	**res;
	int		count;
	int		i;
	int		start;
	int		len;

	if (!s)
		return (NULL);
	count = 0;
	i = 0;
	while (s[i])
	{
		while (s[i] && is_ifs(s[i]))
			i++;
		if (!s[i])
			break ;
		count++;
		while (s[i] && !is_ifs(s[i]))
			i++;
	}
	res = safe_malloc((count + 1) * sizeof(char *));
	i = 0;
	len = 0;
	start = 0;
	count = 0;
	while (s[i])
	{
		while (s[i] && is_ifs(s[i]))
			i++;
		if (!s[i])
			break ;
		start = i;
		while (s[i] && !is_ifs(s[i]))
			i++;
		len = i - start;
		res[count] = safe_substr(s, start, len);
		count++;
	}
	res[count] = NULL;
	return (res);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_commands_helpers.c                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelona.co  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/04 15:22:05 by jadelgad          #+#    #+#             */
/*   Updated: 2026/02/04 15:22:08 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

int	check_io_number(int type, t_cmd_info *i)
{
	if ((type == TOKEN_REDIR_OUT || type == TOKEN_REDIR_APPEND)
		&& i->last_word
		&& i->last_word->type == TOKEN_WORD
		&& is_all_digits(i->last_word->text)
		&& i->last_word->join_next
		&& !i->last_word->was_quoted)
	{
		i->last_word->is_io_number = 1;
		return (ft_atoi(i->last_word->text));
	}
	return (-1);
}

int	is_redir_token(int type)
{
	if (type == TOKEN_REDIR_IN || type == TOKEN_REDIR_OUT
		|| type == TOKEN_REDIR_APPEND || type == TOKEN_HEREDOC)
		return (1);
	return (0);
}

int	get_default_fd(int type)
{
	if (type == TOKEN_REDIR_IN || type == TOKEN_HEREDOC)
		return (0);
	return (1);
}

char	*get_redir_file(int type, char *text)
{
	if (type == TOKEN_HEREDOC)
		return (create_heredoc_tmp(text));
	return (ft_strdup(text));
}

int	count_pieces(const char *s, int was_quoted)
{
	int	count;
	int	in_word;

	if (was_quoted)
		return (1);
	count = 0;
	in_word = 0;
	while (*s)
	{
		if (*s == ' ' || *s == '\t' || *s == '\n')
		{
			if (in_word)
				in_word = 0;
		}
		else
		{
			if (!in_word)
			{
				in_word = 1;
				count++;
			}
		}
		s++;
	}
	return (count);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_commands.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelona.co  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/04 15:22:05 by jadelgad          #+#    #+#             */
/*   Updated: 2026/02/04 15:22:08 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

static int	handle_redirs(t_parser_context *ctx, t_ast **cmd,
						t_token **tok, t_cmd_info *i)
{
	int		type;
	char	*file;
	int		fd;

	while (*tok && is_redir_token((*tok)->type))
	{
		type = (*tok)->type;
		fd = check_io_number(type, i);
		*tok = (*tok)->next;
		if (!*tok || (*tok)->type != TOKEN_WORD)
			return (set_parser_error(ctx, "syntax error", *tok), 0);
		file = get_redir_file(type, (*tok)->text);
		if (!file)
			return (0);
		*cmd = ast_new_redirect(*cmd, file, type);
		if (fd == -1)
			fd = get_default_fd(type);
		(*cmd)->redirect_fd = fd;
		*tok = (*tok)->next;
		i->last_word = NULL;
	}
	return (1);
}

/* Cuenta argumentos y encuentra la 'last_word' */
static void	count_elements(t_cmd_info *info, t_token *tok)
{
	t_token	*tmp;

	tmp = tok;
	while (tmp && (tmp->type == TOKEN_WORD || tmp->type == TOKEN_EXPANSION)
		&& is_assignment_word(tmp->text))
	{
		info->assign_count++;
		tmp = tmp->next;
	}
	info->words_start = tmp;
	while (tmp && (tmp->type == TOKEN_WORD
			|| tmp->type == TOKEN_EXPANSION || is_redir_token(tmp->type)))
	{
		if (is_redir_token(tmp->type))
		{
			tmp = tmp->next;
			if (tmp)
				tmp = tmp->next;
			continue ;
		}
		info->argc += count_pieces(tmp->text, tmp->was_quoted);
		if (tmp->type == TOKEN_WORD)
			info->last_word = tmp;
		tmp = tmp->next;
	}
}

/* Reserva memoria y rellena argv/assignments */
static int	fill_arrays(t_cmd_info *info, t_token *tok)
{
	int		i;
	char	**pieces;
	int		j;

	info->assigns = safe_malloc((info->assign_count + 1) * sizeof(char *));
	info->argv = safe_malloc((info->argc + 1) * sizeof(char *));
	info->argv_quoted = safe_malloc((info->argc + 1) * sizeof(int));
	if (!info->assigns || !info->argv || !info->argv_quoted)
		return (0);
	i = 0;
	while (i < info->assign_count)
	{
		info->assigns[i++] = ft_strdup(tok->text);
		tok = tok->next;
	}
	info->assigns[i] = NULL;
	i = 0;
	tok = info->words_start;
	while (tok && (tok->type == TOKEN_WORD
			|| tok->type == TOKEN_EXPANSION || is_redir_token(tok->type)))
	{
		if (is_redir_token(tok->type))
		{
			tok = tok->next;
			if (tok)
				tok = tok->next;
			continue ;
		}
		if (!tok->is_io_number)
		{
			if (tok->was_quoted)
			{
				info->argv[i] = ft_strdup(tok->text);
				info->argv_quoted[i] = 1;
				i++;
			}
			else
			{
				pieces = split_by_ifs(tok->text);
				j = 0;
				while (pieces && pieces[j])
				{
					info->argv[i] = ft_strdup(pieces[j]);
					info->argv_quoted[i] = 0;
					i++;
					j++;
				}
				free_split(pieces);
			}
		}
		tok = tok->next;
	}
	info->argv[i] = NULL;
	info->argv_quoted[i] = 0;
	return (1);
}

/* Pega los arrays al comando base */
static void	attach_to_base(t_ast *cmd, t_cmd_info *i)
{
	t_ast	*base;

	base = cmd;
	while (base && base->type == AST_REDIRECT)
		base = base->left;
	if (base && base->type == AST_COMMAND)
	{
		base->argv = i->argv;
		base->assignments = i->assigns;
		base->argv_quoted = i->argv_quoted;
	}
}

t_ast	*parser_commands(t_token **ptokens, t_parser_context *ctx)
{
	t_cmd_info	info;
	t_ast		*cmd;
	t_token		*tok;
	t_token		*scan;
	t_token		*suffix_tok;

	tok = *ptokens;
	ft_memset(&info, 0, sizeof(t_cmd_info));
	cmd = ast_new_command(NULL, NULL);
	if (!cmd || !handle_redirs(ctx, &cmd, &tok, &info))
		return (ast_free(cmd), NULL);
	count_elements(&info, tok);
	if (info.assign_count == 0 && info.argc == 0 && cmd->type != AST_REDIRECT)
		return (set_parser_error(ctx, "empty cmd", tok), ast_free(cmd), NULL);
	scan = info.words_start;
	while (scan && (scan->type == TOKEN_WORD
			|| scan->type == TOKEN_EXPANSION
			|| is_redir_token(scan->type)))
	{
		if (is_redir_token(scan->type))
		{
			if (!handle_redirs(ctx, &cmd, &scan, &info))
				return (ast_free(cmd), NULL);
			continue ;
		}
		scan = scan->next;
	}
	suffix_tok = scan;
	if (!fill_arrays(&info, tok))
		return (ast_free(cmd), NULL);
	attach_to_base(cmd, &info);
	*ptokens = suffix_tok;
	return (cmd);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ast_error.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelona.co  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/04 15:20:02 by jadelgad          #+#    #+#             */
/*   Updated: 2026/02/04 15:20:04 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

/* Recursively frees an AST children list. */
void	ast_list_free(t_ast_list *list)
{
	if (!list)
		return ;
	ast_free(list->node);
	ast_list_free(list->next);
	free(list);
}

void	ast_free(t_ast *node)
{
	if (!node)
		return ;
	ast_free(node->left);
	ast_free(node->right);
	ast_list_free(node->children);
	free_argv(node->argv);
	free(node->argv_quoted);
	free_assignments(node->assignments);
	free(node->file);
	free(node);
}

/* Error Handling */
int	ft_strlen_const(const char *str)
{
	int	i;

	i = 0;
	if (!str)
		return (0);
	while (str[i])
		i++;
	return (i);
}

/*
Formato estándar Minishell:
minishell: syntax error near unexpected token `...'\n
- Ignora el texto heredado en `message`.
- No imprime errno ni "System error" para errores de parsing.
- Usa `newline` al final de la entrada.
*/
void	ast_parser_error(const char *message, t_token *token)
{
	const char	*prefix;
	const char	*msg;
	const char	*end;
	const char	*tokstr;

	if (g_signal_received == SIGINT)
		return ;
	(void)message;
	prefix = "minishell: ";
	msg = "syntax error near unexpected token `";
	end = "'\n";
	tokstr = token_text_or_newline(token);
	write(2, prefix, ft_strlen_const(prefix));
	write(2, msg, ft_strlen_const(msg));
	write(2, tokstr, ft_strlen_const(tokstr));
	write(2, end, ft_strlen_const(end));
	errno = 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_all.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelona.co  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/04 15:21:21 by jadelgad          #+#    #+#             */
/*   Updated: 2026/02/04 15:21:23 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

t_ast	*parser_logical(t_token **ptokens, t_parser_context *ctx)
{
	t_token			*token;
	t_token_type	type;
	t_ast			*left;
	t_ast			*right;

	token = *ptokens;
	if (token && (token->type == TOKEN_AND || token->type == TOKEN_OR))
		return (set_parser_error(ctx, "operator at start", token), NULL);
	left = parser_pipe(&token, ctx);
	if (ctx->error_status)
		return (NULL);
	while (token && (token->type == TOKEN_AND || token->type == TOKEN_OR))
	{
		type = token->type;
		token = token->next;
		if (!token)
			return (set_parser_error(ctx, "operator at end", token), NULL);
		right = parser_pipe(&token, ctx);
		if (ctx->error_status)
			return (ast_free(left), NULL);
		left = create_logic_node(type, left, right);
	}
	*ptokens = token;
	return (left);
}

/*static t_ast	*parse_pipe_sequence(t_ast *left, t_token **tok,
									t_parser_context *ctx)
{
	t_ast_list	*list;
	t_ast		*right;

	list = ast_list_new(left);
	if (!list)
		return (ast_free(left), NULL);
	while (*tok && (*tok)->type == TOKEN_PIPE)
	{
		*tok = (*tok)->next;
		if (!*tok || ((*tok)->type != TOKEN_WORD
				&& (*tok)->type != TOKEN_LPAREN))
		{
			set_parser_error(ctx, "expected cmd after pipe", *tok);
			return (ast_list_free(list), NULL);
		}
		right = parser_command_or_subshell(tok, ctx);
		if (ctx->error_status)
			return (ast_list_free(list), NULL);
		list = ast_list_append(list, right);
	}
	return (ast_new_pipe(list));
}
*/
t_ast	*parser_pipe(t_token **ptokens, t_parser_context *ctx)
{
	t_token	*tok;
	t_ast	*node;

	tok = *ptokens;
	if (tok && tok->type == TOKEN_PIPE)
		return (set_parser_error(ctx, "pipe at start", tok), NULL);
	node = parser_command_or_subshell(&tok, ctx);
	if (!ctx->error_status && tok && tok->type == TOKEN_PIPE)
		node = parse_pipe_sequence(node, &tok, ctx);
	*ptokens = tok;
	return (node);
}

t_ast	*parser_subshell(t_token **ptokens, t_parser_context *ctx)
{
	t_token	*token;
	t_ast	*subshell;
	t_ast	*cmd;

	token = *ptokens;
	cmd = NULL;
	if (token && token->type == TOKEN_LPAREN)
	{
		token = token->next;
		subshell = parser_logical(&token, ctx);
		if (ctx->error_status)
			return (NULL);
		if (!token || token->type != TOKEN_RPAREN)
		{
			set_parser_error(ctx, "missing the ')'", token);
			ast_free(subshell);
			return (NULL);
		}
		token = token->next;
		cmd = ast_new_subshell(subshell);
	}
	*ptokens = token;
	return (cmd);
}

t_ast	*parser_command_or_subshell(t_token **ptokens, t_parser_context *ctx)
{
	t_ast	*node;

	node = NULL;
	if (*ptokens && (*ptokens)->type == TOKEN_LPAREN)
		node = parser_subshell(ptokens, ctx);
	else
		node = parser_commands(ptokens, ctx);
	if (ctx->error_status)
		return (NULL);
	return (node);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ast_init.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelona.co  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/04 15:20:11 by jadelgad          #+#    #+#             */
/*   Updated: 2026/02/04 15:20:13 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

// Logic AND/OR node constructor
t_ast	*ast_new_and(t_ast *left, t_ast *right)
{
	t_ast	*node;

	node = safe_malloc(sizeof(t_ast));
	node->type = AST_AND;
	node->left = left;
	node->right = right;
	node->argv = NULL;
	node->assignments = NULL;
	node->file = NULL;
	node->redirect_type = 0;
	node->redirect_fd = -1;
	node->children = NULL;
	node->argv_quoted = NULL;
	return (node);
}

t_ast	*ast_new_or(t_ast *left, t_ast *right)
{
	t_ast	*node;

	node = safe_malloc(sizeof(t_ast));
	node->type = AST_OR;
	node->left = left;
	node->right = right;
	node->argv = NULL;
	node->assignments = NULL;
	node->file = NULL;
	node->redirect_type = 0;
	node->redirect_fd = -1;
	node->children = NULL;
	node->argv_quoted = NULL;
	return (node);
}

// Subshell node constructor
t_ast	*ast_new_subshell(t_ast *child)
{
	t_ast	*node;

	node = malloc(sizeof(t_ast));
	node->type = AST_SUBSHELL;
	node->left = child;
	node->right = NULL;
	node->argv = NULL;
	node->assignments = NULL;
	node->file = NULL;
	node->redirect_type = 0;
	node->redirect_fd = -1;
	node->children = NULL;
	node->argv_quoted = NULL;
	return (node);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ast_token_utils.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelona.co  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/04 15:20:37 by jadelgad          #+#    #+#             */
/*   Updated: 2026/02/04 15:20:42 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
Token Utilities (in Parser)
------------------------------
t_token *token_next_word(t_token *tok);
Skips non-word tokens, returns next word token.

t_token *token_skip_until(t_token *tok, t_token_type type);
Skips tokens until it finds a desired type (e.g., pipe, redirect).
*/

#include "nanoshell.h"

t_token	*token_next_word(t_token *token)
{
	while (token && token->type != TOKEN_WORD)
		token = token->next;
	return (token);
}

t_token	*token_skip_until(t_token *token, t_token_type type)
{
	while (token && token->type != type)
		token = token->next;
	return (token);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parser_all_helpers.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelona.co  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/04 15:21:21 by jadelgad          #+#    #+#             */
/*   Updated: 2026/02/04 15:21:23 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

t_ast	*create_logic_node(t_token_type type, t_ast *left, t_ast *right)
{
	if (type == TOKEN_AND)
		return (ast_new_and(left, right));
	return (ast_new_or(left, right));
}

/*parse_pipe_sequence impide iniciar con redirecciones tras ‘|’.
En bash/minishell sí es válido.
Cambio sugerido: ampliar la condición.*/
t_ast	*parse_pipe_sequence(t_ast *left, t_token **tok,
									t_parser_context *ctx)
{
	t_ast_list	*list;
	t_ast		*right;

	list = ast_list_new(left);
	if (!list)
		return (ast_free(left), NULL);
	while (*tok && (*tok)->type == TOKEN_PIPE)
	{
		*tok = (*tok)->next;
		if (!*tok || ((*tok)->type != TOKEN_WORD
				&& (*tok)->type != TOKEN_LPAREN
				&& (*tok)->type != TOKEN_REDIR_IN
				&& (*tok)->type != TOKEN_REDIR_OUT
				&& (*tok)->type != TOKEN_REDIR_APPEND
				&& (*tok)->type != TOKEN_HEREDOC))
		{
			set_parser_error(ctx, "expected cmd after pipe", *tok);
			return (ast_list_free(list), NULL);
		}
		right = parser_command_or_subshell(tok, ctx);
		if (ctx->error_status)
			return (ast_list_free(list), NULL);
		list = ast_list_append(list, right);
	}
	return (ast_new_pipe(list));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ast_init_helper.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelona.co  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/04 15:20:11 by jadelgad          #+#    #+#             */
/*   Updated: 2026/02/04 15:20:13 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

// Command node constructor
t_ast	*ast_new_command(char **tokens, char **assignments)
{
	t_ast	*node;

	node = safe_malloc(sizeof(t_ast));
	node->type = AST_COMMAND;
	node->left = NULL;
	node->right = NULL;
	node->argv = tokens;
	node->assignments = assignments;
	node->file = NULL;
	node->redirect_type = 0;
	node->redirect_fd = -1;
	node->children = NULL;
	node->argv_quoted = NULL;
	return (node);
}

// Pipe node constructor
t_ast	*ast_new_pipe(t_ast_list *children)
{
	t_ast	*node;

	node = safe_malloc(sizeof(t_ast));
	node->type = AST_PIPE;
	node->left = NULL;
	node->right = NULL;
	node->argv = NULL;
	node->assignments = NULL;
	node->file = NULL;
	node->redirect_type = 0;
	node->redirect_fd = -1;
	node->children = children;
	node->argv_quoted = NULL;
	return (node);
}

// Redirect node constructor
t_ast	*ast_new_redirect(t_ast *cmd, char *file, int redirect_type)
{
	t_ast	*node;

	node = safe_malloc(sizeof(t_ast));
	node->type = AST_REDIRECT;
	node->left = cmd;
	node->right = NULL;
	node->argv = NULL;
	node->assignments = NULL;
	node->file = file;
	node->redirect_type = redirect_type;
	node->children = NULL;
	node->argv_quoted = NULL;
	if (redirect_type == TOKEN_REDIR_IN || redirect_type == TOKEN_HEREDOC)
		node->redirect_fd = 0;
	else
		node->redirect_fd = 1;
	return (node);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ast_error_helper.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelona.co  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/04 15:20:02 by jadelgad          #+#    #+#             */
/*   Updated: 2026/02/04 15:20:04 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

/* free ast_nodes & children */
void	free_argv(char **argv)
{
	int	i;

	if (!argv)
		return ;
	i = 0;
	while (argv[i])
	{
		free(argv[i]);
		i++;
	}
	free(argv);
}

void	free_assignments(char **assignments)
{
	int	i;

	if (!assignments)
		return ;
	i = 0;
	while (assignments[i])
	{
		free(assignments[i]);
		i++;
	}
	free(assignments);
}

int	is_token_text(const t_token *token)
{
	if (!token)
		return (0);
	if (token->text && token->text[0] != '\0')
		return (1);
	return (0);
}

const char	*token_display_fallback(const t_token *token)
{
	if (!token)
		return ("newline");
	if (token->type == TOKEN_PIPE)
		return ("|");
	if (token->type == TOKEN_REDIR_OUT)
		return (">");
	if (token->type == TOKEN_REDIR_APPEND)
		return (">>");
	if (token->type == TOKEN_REDIR_IN)
		return ("<");
	if (token->type == TOKEN_HEREDOC)
		return ("<<");
	if (token->type == TOKEN_AND)
		return ("&&");
	if (token->type == TOKEN_OR)
		return ("||");
	if (token->type == TOKEN_LPAREN)
		return ("(");
	if (token->type == TOKEN_RPAREN)
		return (")");
	return ("newline");
}

const char	*token_text_or_newline(const t_token *token)
{
	if (!token || token->type == TOKEN_EOF)
		return ("newline");
	if (is_token_text(token))
		return (token->text);
	return (token_display_fallback(token));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ast_utils.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelona.co  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/04 15:21:05 by jadelgad          #+#    #+#             */
/*   Updated: 2026/02/04 15:21:07 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

// AST List Management
// Creates a new list node.
t_ast_list	*ast_list_new(t_ast *node)
{
	t_ast_list	*list;

	list = safe_malloc(sizeof(t_ast_list));
	list->node = node;
	list->next = NULL;
	return (list);
}

// Appends a node to the end of a children list.
t_ast_list	*ast_list_append(t_ast_list *head, t_ast *node)
{
	t_ast_list	*tmp;
	t_ast_list	*new_node;

	if (!node)
		return (head);
	new_node = ast_list_new(node);
	if (!head)
		return (new_node);
	tmp = head;
	while (tmp->next)
		tmp = tmp->next;
	tmp->next = new_node;
	return (head);
}

// for commands
int	ast_count_args(char **argv)
{
	int	count;

	count = 0;
	while (argv[count])
		count++;
	return (count);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main_helpers.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/03 14:58:53 by jadelgad          #+#    #+#             */
/*   Updated: 2026/02/11 14:24:46 by alemonto         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

char	*get_input_line(t_data *data)
{
	char	*prompt;
	char	*line;

	prompt = build_prompt(data);
	if (prompt)
		line = readline(prompt);
	else
		line = readline("minishell$ ");
	free(prompt);
	return (line);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   basic_utils.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelona.co  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/04 15:22:57 by jadelgad          #+#    #+#             */
/*   Updated: 2026/02/04 15:22:59 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

int	is_space(char c)
{
	if (c == ' ' || (c >= 9 && c <= 13))
		return (1);
	return (0);
}

int	is_operator(char c)
{
	if (c == '<' || c == '>' || c == '|'
		|| c == '&' || c == '(' || c == ')')
		return (1);
	return (0);
}

void	skip_spaces(const char *line, size_t *i, size_t len)
{
	while (*i < len && is_space(line[*i]))
		(*i)++;
}

void	*safe_malloc(size_t size)
{
	void	*ptr;

	ptr = malloc(size);
	if (!ptr)
	{
		perror("Malloc failed");
		exit(EXIT_FAILURE);
	}
	return (ptr);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   basic_utils_helper.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelona.co  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/04 15:22:57 by jadelgad          #+#    #+#             */
/*   Updated: 2026/02/04 15:22:59 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

int	ft_strcmp(const char *s1, const char *s2)
{
	int	i;

	i = 0;
	while (s1[i] && s2[i] && s1[i] == s2[i])
		i++;
	return ((unsigned char)s1[i] - (unsigned char)s2[i]);
}

void	ft_swap_str(char **a, char **b)
{
	char	*tmp;

	tmp = *a;
	*a = *b;
	*b = tmp;
}

int	is_all_digits(const char *s)
{
	int	i;

	if (!s || !*s)
		return (0);
	i = 0;
	while (s[i])
	{
		if (!ft_isdigit(s[i]))
			return (0);
		i++;
	}
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   display_token.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/13 13:02:42 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/13 13:15:50 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

static void	print_escaped(const char *s)
{
	if (!s)
	{
		printf("(null)");
		return ;
	}
	print_escaped_loop(s);
}

void	tokens_print_simple(const t_token *head)
{
	t_token		*cur;
	int			idx;
	const char	*raw;
	const char	*display;

	cur = (t_token *)head;
	idx = 1;
	while (cur)
	{
		raw = cur->text;
		display = display_text_for_token(cur);
		printf("token%-3d type=%-12s pos=%4zu quote=%-6s raw=\"",
			idx, type_to_str(cur->type), cur->pos, quote_to_str(cur->quote));
		print_escaped(raw);
		printf("\" display=\"");
		printf("%s", display);
		if (cur->type == TOKEN_ERROR)
			printf("  <-- ERROR");
		printf("\n");
		cur = cur->next;
		idx++;
	}
}

static void	print_token_header(const t_token *t, size_t i)
{
	printf("token");
	printf("%-3zu", i + 1);
	printf(" type=");
	printf("%-12s", type_to_str(t->type));
	printf(" pos=");
	printf("%4d", (int)t->pos);
	printf(" quote=");
	printf("%-6s", quote_to_str(t->quote));
	printf(" raw=\"");
}

static void	print_token_display_and_close(const t_token *t)
{
	const char	*display;

	printf("\" display=\"");
	display = display_text_for_token(t);
	if (display)
		printf("%s", display);
	printf("\"\n");
}

void	tokens_print_simple_array(const t_token **arr, size_t count)
{
	size_t			i;
	const t_token	*t;

	i = 0;
	while (i < count)
	{
		t = arr[i];
		if (!t)
		{
			print_null_token(i);
		}
		else
		{
			print_token_header(t, i);
			print_escaped(t->text);
			print_token_display_and_close(t);
		}
		i++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokenizer_helper.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/13 13:31:36 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/13 13:32:43 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

int	skip_spaces_with_flag(const char *line, size_t *i, size_t len)
{
	size_t	before;

	before = *i;
	skip_spaces(line, i, len);
	if (*i > before)
		return (1);
	return (0);
}

void	set_prev_join_next(t_token **head, int had_space)
{
	t_token	*prev;

	prev = *head;
	while (prev && prev->next)
		prev = prev->next;
	if (!prev)
		return ;
	if (had_space)
		prev->join_next = 0;
	else
		prev->join_next = 1;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   token_quotes.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/12 13:50:51 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/13 14:27:58 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

int	parse_single_quote(t_buf *buf, const char *line, size_t *i, size_t len)
{
	while (*i < len && line[*i] != '\'')
	{
		if (buf_append_char(buf, line[*i]) < 0)
			return (-1);
		(*i)++;
	}
	if (*i >= len)
		return (-1);
	(*i)++;
	return (0);
}

int	parse_double_quote(t_quote_ctx *ctx, size_t *i)
{
	while (*i < ctx->len && ctx->line[*i] != '"')
	{
		if (ctx->line[*i] == '\\' && (*i + 1) < ctx->len)
		{
			(*i)++;
			if (buf_append_char(ctx->buf, ctx->line[*i]) < 0)
				return (-1);
			(*i)++;
			continue ;
		}
		if (ctx->line[*i] == '$')
		{
			if (expand_dollar_ctx(ctx, i) < 0)
				return (-1);
			continue ;
		}
		if (buf_append_char(ctx->buf, ctx->line[*i]) < 0)
			return (-1);
		(*i)++;
	}
	if (*i >= ctx->len)
		return (-1);
	(*i)++;
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   buffer_utils_helper.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/08 15:51:26 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/12 15:09:49 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

void	buf_init(t_buf *b)
{
	b->data = NULL;
	b->len = 0;
	b->cap = 0;
}

void	buf_free(t_buf *b)
{
	if (!b)
		return ;
	free(b->data);
	b->data = NULL;
	b->len = 0;
	b->cap = 0;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   token_words.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/12 14:06:18 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/12 15:03:28 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

static t_quote_type	quote_type_from_flags(int seen_single, int seen_double,
	int seen_unquoted)
{
	if ((seen_single && seen_double)
		|| (seen_single && seen_unquoted) || (seen_double && seen_unquoted))
		return (QT_MIXED);
	if (seen_single)
		return (QT_SINGLE);
	if (seen_double)
		return (QT_DOUBLE);
	if (seen_unquoted)
		return (QT_NONE);
	return (QT_NONE);
}

static t_token	*finalize_token_from_ctx(size_t start, t_word_ctx *ctx)
{
	char			*text;
	t_quote_type	qt;
	t_token			*tok;

	text = buf_release(&ctx->buf);
	if (!text)
		return (NULL);
	qt = quote_type_from_flags(ctx->seen_single, ctx->seen_double,
			ctx->seen_unquoted);
	tok = token_new(TOKEN_WORD, text, qt, (int)start);
	if (!tok)
		return (NULL);
	tok->was_quoted = ctx->was_quoted;
	return (tok);
}
// is_io_number y join_next ya están a 0 por defecto

static t_token	*build_word_token_ctx(t_word_src *src, size_t *i, size_t start)
{
	t_word_ctx	ctx;
	int			rc;
	t_token		*tok;

	ctx.seen_single = 0;
	ctx.seen_double = 0;
	ctx.seen_unquoted = 0;
	ctx.was_quoted = 0;
	buf_init(&ctx.buf);
	rc = process_chars_ctx(&ctx, src, i);
	if (rc != 0)
	{
		if (rc == -1)
			return (make_error_token_from_ctx(start,
					"unclosed single quote", &ctx));
		if (rc == -2)
			return (make_error_token_from_ctx(start,
					"unclosed double quote", &ctx));
		free(ctx.buf.data);
		return (NULL);
	}
	tok = finalize_token_from_ctx(start, &ctx);
	return (tok);
}

/* <= 4 args: src + i */
t_token	*parse_word_ctx(t_word_src *src, size_t *i)
{
	size_t	start;

	if (!src || !src->line || !i)
		return (NULL);
	start = *i;
	return (build_word_token_ctx(src, i, start));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   display_token_helper.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/13 13:02:42 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/13 13:15:50 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

const char	*type_to_str(t_token_type t)
{
	if (t == TOKEN_WORD)
		return ("WORD");
	if (t == TOKEN_PIPE)
		return ("PIPE");
	if (t == TOKEN_REDIR_IN)
		return ("REDIR_IN");
	if (t == TOKEN_REDIR_OUT)
		return ("REDIR_OUT");
	if (t == TOKEN_REDIR_APPEND)
		return ("REDIR_APPEND");
	if (t == TOKEN_HEREDOC)
		return ("HEREDOC");
	if (t == TOKEN_AND)
		return ("AND");
	if (t == TOKEN_OR)
		return ("OR");
	if (t == TOKEN_LPAREN)
		return ("LPAREN");
	if (t == TOKEN_RPAREN)
		return ("RPAREN");
	if (t == TOKEN_EOF)
		return ("EOF");
	if (t == TOKEN_ERROR)
		return ("ERROR");
	return ("UNKNOWN");
}

const char	*quote_to_str(t_quote_type q)
{
	if (q == QT_NONE)
		return ("NONE");
	if (q == QT_SINGLE)
		return ("SINGLE");
	if (q == QT_DOUBLE)
		return ("DOUBLE");
	if (q == QT_MIXED)
		return ("MIXED");
	return ("UNKNOWN");
}

const char	*display_text_for_type(int type)
{
	if (type == TOKEN_PIPE)
		return ("|");
	else if (type == TOKEN_REDIR_OUT)
		return (">");
	else if (type == TOKEN_REDIR_APPEND)
		return (">>");
	else if (type == TOKEN_REDIR_IN)
		return ("<");
	else if (type == TOKEN_HEREDOC)
		return ("<<");
	else if (type == TOKEN_AND)
		return ("&&");
	else if (type == TOKEN_OR)
		return ("||");
	else if (type == TOKEN_LPAREN)
		return ("(");
	else if (type == TOKEN_RPAREN)
		return (")");
	else if (type == TOKEN_EOF)
		return ("EOF");
	else if (type == TOKEN_ERROR)
		return ("ERROR");
	return ("");
}

const char	*display_text_for_token(const t_token *t)
{
	if (t == NULL)
		return ("");
	if (t->text && t->text[0] != '\0')
		return (t->text);
	return (display_text_for_type(t->type));
}

void	print_escaped_char(unsigned char c)
{
	if (c == '\n')
		printf("\\n");
	else if (c == '\r')
		printf("\\r");
	else if (c == '\t')
		printf("\\t");
	else if (c == '\b')
		printf("\\b");
	else if (c == '\a')
		printf("\\a");
	else if (c == '\v')
		printf("\\v");
	else if (c == '\\')
		printf("\\\\");
	else if (c == '\"')
		printf("\\\"");
	else if (ft_isprint(c))
		write(1, &c, 1);
	else
		printf("\\x%02x", c);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   token_operator.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/13 13:00:48 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/13 14:16:58 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

static t_token	*handle_less(const char *line,
	size_t *i, size_t len, size_t pos)
{
	if (*i + 1 < len && line[*i + 1] == '<' )
	{
		*i += 2;
		return (token_new(TOKEN_HEREDOC, ft_strdup("<<"), QT_NONE, pos));
	}
	*i += 1;
	return (token_new(TOKEN_REDIR_IN, ft_strdup("<"), QT_NONE, pos));
}

static t_token	*handle_pipe_or_or(const char *line,
	size_t *i, size_t len, size_t pos)
{
	if (*i + 1 < len && line[*i + 1] == '|')
	{
		*i += 2;
		return (token_new(TOKEN_OR, ft_strdup("||"), QT_NONE, pos));
	}
	*i += 1;
	return (token_new(TOKEN_PIPE, ft_strdup("|"), QT_NONE, pos));
}

static t_token	*handle_and_or_amp(const char *line,
	size_t *i, size_t len, size_t pos)
{
	if (*i + 1 < len && line[*i + 1] == '&')
	{
		*i += 2;
		return (token_new(TOKEN_AND, ft_strdup("&&"), QT_NONE, pos));
	}
	*i += 1;
	return (token_new(TOKEN_WORD, ft_strdup("&"), QT_NONE, pos));
}

static t_token	*handle_paren(const char *line,
	size_t *i, size_t len, size_t pos)
{
	(void)len;
	if (line[*i] == '(')
	{
		*i += 1;
		return (token_new(TOKEN_LPAREN, ft_strdup("("), QT_NONE, pos));
	}
	*i += 1;
	return (token_new(TOKEN_RPAREN, ft_strdup(")"), QT_NONE, pos));
}

t_token	*parse_operator(const char *line, size_t *i, size_t len)
{
	size_t	pos;

	if (!line || !i)
		return (NULL);
	pos = *i;
	if (line[*i] == '>')
		return (handle_greater(line, i, len, pos));
	if (line[*i] == '<')
		return (handle_less(line, i, len, pos));
	if (line[*i] == '|')
		return (handle_pipe_or_or(line, i, len, pos));
	if (line[*i] == '&')
		return (handle_and_or_amp(line, i, len, pos));
	if (line[*i] == '(' || line[*i] == ')')
		return (handle_paren(line, i, len, pos));
	return (NULL);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   token_utils.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/08 14:35:49 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/12 14:40:08 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

t_token	*token_new(t_token_type type, char *text, t_quote_type qt, int pos)
{
	t_token	*t;

	t = malloc(sizeof(t_token));
	if (!t)
	{
		free(text);
		return (NULL);
	}
	t->type = type;
	t->text = text;
	t->quote = qt;
	t->pos = pos;
	t->is_io_number = 0;
	t->join_next = 0;
	t->was_quoted = 0;
	t->next = NULL;
	return (t);
}

void	token_append(t_token **head, t_token *node)
{
	t_token	*cur;

	if (!node)
		return ;
	if (!*head)
	{
		*head = node;
		return ;
	}
	cur = *head;
	while (cur->next)
		cur = cur->next;
	cur->next = node;
}

void	free_tokens(t_token *head)
{
	t_token	*cur;
	t_token	*n;

	cur = head;
	while (cur)
	{
		n = cur->next;
		if (cur->text)
			free(cur->text);
		free(cur);
		cur = n;
	}
}

t_token	*make_error_token_from_ctx(size_t start, const char *msg,
	t_word_ctx *ctx)
{
	char	*m;

	free(ctx->buf.data);
	m = ft_strdup(msg);
	if (!m)
		return (NULL);
	return (token_new(TOKEN_ERROR, m, QT_NONE, (int)start));
}

t_token	*handle_greater(const char *line,
	size_t *i, size_t len, size_t pos)
{
	if (*i + 1 < len && line[*i + 1] == '>')
	{
		*i += 2;
		return (token_new(TOKEN_REDIR_APPEND, ft_strdup(">>"), QT_NONE, pos));
	}
	*i += 1;
	return (token_new(TOKEN_REDIR_OUT, ft_strdup(">"), QT_NONE, pos));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   buffer_utils.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/08 15:51:26 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/12 15:09:49 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

int	buf_append_str(t_buf *b, const char *s)
{
	size_t	slen;

	if (!b || !s)
		return (0);
	slen = ft_strlen(s);
	if (slen == 0)
		return (0);
	if (buf_ensure_capacity(b, b->len + slen + 1) != 0)
		return (-1);
	ft_memcpy(b->data + b->len, s, slen);
	b->len += slen;
	b->data[b->len] = '\0';
	return (0);
}

static size_t	next_capacity(size_t cur, size_t min_needed)
{
	size_t	ncap;

	if (min_needed == 0)
		return (0);
	if (cur == 0)
		ncap = 32;
	else
	{
		ncap = cur * 2;
	}
	while (ncap < min_needed)
	{
		if (ncap > SIZE_MAX / 2)
		{
			ncap = min_needed;
			break ;
		}
		ncap *= 2;
	}
	if (ncap < min_needed)
		ncap = min_needed;
	return (ncap);
}

int	buf_ensure_capacity(t_buf *b, size_t min_needed)
{
	size_t	ncap;
	char	*n;

	if (!b)
		return (-1);
	if (b->cap >= min_needed)
		return (0);
	ncap = next_capacity(b->cap, min_needed);
	n = malloc(ncap);
	if (!n)
		return (-1);
	if (b->data && b->len > 0)
		ft_memcpy(n, b->data, b->len + 1);
	else
	{
		n[0] = '\0';
	}
	free(b->data);
	b->data = n;
	b->cap = ncap;
	return (0);
}

int	buf_append_char(t_buf *b, char c)
{
	size_t	required;

	if (!b)
		return (-1);
	required = b->len + 2;
	if (buf_ensure_capacity(b, required) != 0)
		return (-1);
	b->data[b->len++] = c;
	b->data[b->len] = '\0';
	return (0);
}

char	*buf_release(t_buf *buf)
{
	char	*ret;

	if (!buf)
		return (NULL);
	if (buf->data == NULL)
	{
		ret = malloc(1);
		if (!ret)
			return (NULL);
		ret[0] = '\0';
		buf->len = 0;
		buf->cap = 0;
		return (ret);
	}
	ret = buf->data;
	buf->data = NULL;
	buf->len = 0;
	buf->cap = 0;
	return (ret);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expand_handlers.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/29 11:51:07 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/29 11:51:12 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

static int	append_env_by_name(t_buf *buf, const char *name, t_data *data)
{
	const char	*val;
	int			rc;

	if (!buf || !name || !data)
		return (0);
	val = get_var_from_envp(data->envp, name);
	if (!val)
		return (0);
	rc = buf_append_str(buf, val);
	if (rc < 0)
		return (-1);
	return (0);
}

static int	append_literal_range(t_buf *buf, const char *line,
		size_t start, size_t end)
{
	while (start < end)
	{
		if (buf_append_char(buf, line[start]) < 0)
			return (-1);
		start++;
	}
	return (0);
}

static int	braced_unclosed_append(t_buf *buf, const char *line,
		size_t start, size_t current)
{
	if (!buf || !line)
		return (-1);
	if (buf_append_char(buf, '$') < 0)
		return (-1);
	if (buf_append_char(buf, '{') < 0)
		return (-1);
	if (append_literal_range(buf, line, start, current) < 0)
		return (-1);
	return (0);
}

int	handle_braced_ctx(t_expand_ctx *ctx, size_t *i)
{
	size_t	start;
	size_t	idlen;
	char	*name;
	int		rc;

	if (!ctx || !i)
		return (-1);
	(*i)++;
	start = *i;
	idlen = parse_identifier_len(ctx->line, *i, ctx->len);
	*i += idlen;
	if (*i >= ctx->len || ctx->line[*i] != '}')
		return (braced_unclosed_append(ctx->buf, ctx->line, start, *i));
	name = ft_strndup(ctx->line + start, idlen);
	if (!name)
		return (-1);
	(*i)++;
	rc = append_env_by_name(ctx->buf, name, ctx->data);
	free(name);
	if (rc < 0)
		return (-1);
	return (0);
}

int	handle_simple_ctx(t_expand_ctx *ctx, size_t *i)
{
	size_t	idlen;
	char	*name;
	int		rc;

	if (!ctx || !i)
		return (-1);
	idlen = parse_identifier_len(ctx->line, *i, ctx->len);
	if (idlen == 0)
	{
		if (buf_append_char(ctx->buf, '$') < 0)
			return (-1);
		return (0);
	}
	name = ft_strndup(ctx->line + *i, idlen);
	if (!name)
		return (-1);
	*i += idlen;
	rc = append_env_by_name(ctx->buf, name, ctx->data);
	free(name);
	if (rc < 0)
		return (-1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   process_chars_ctx.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/29 11:52:54 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/29 11:52:58 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

/* <= 4 args: usa contexto de comillas y el índice */
static int	handle_double_quote_ctx_word(t_word_ctx *ctx,
		t_quote_ctx *qctx, size_t *i)
{
	int	rc;

	if (!ctx || !qctx || !i)
		return (-2);
	ctx->seen_double = 1;
	ctx->was_quoted = 1;
	(*i)++;
	rc = parse_double_quote(qctx, i);
	if (rc < 0)
		return (-2);
	return (0);
}

/* <= 4 args: usa contexto de comillas y el índice */
static int	handle_dollar_ctx_word(t_word_ctx *ctx,
	t_quote_ctx *qctx, size_t *i)
{
	if (!ctx || !qctx || !i)
		return (-4);
	if (expand_dollar_ctx(qctx, i) < 0)
		return (-4);
	return (0);
}

/* <= 4 args */
int	handle_regular_char(t_word_ctx *ctx, const char *line, size_t *i)
{
	if (!ctx || !line || !i)
		return (-3);
	ctx->seen_unquoted = 1;
	if (buf_append_char(&ctx->buf, line[*i]) < 0)
		return (-3);
	(*i)++;
	return (0);
}

/* <= 4 args: ctx + src + i */
static int	dispatch_char_ctx(t_word_ctx *ctx, t_word_src *src, size_t *i)
{
	char		c;
	t_quote_ctx	qctx;

	c = src->line[*i];
	if (c == '\'')
		return (handle_single_quote(ctx, src->line, i, src->len));
	if (c == '"')
	{
		qctx.buf = &ctx->buf;
		qctx.line = src->line;
		qctx.len = src->len;
		qctx.last_status = src->last_status;
		qctx.data = src->data;
		return (handle_double_quote_ctx_word(ctx, &qctx, i));
	}
	if (c == '$')
	{
		qctx.buf = &ctx->buf;
		qctx.line = src->line;
		qctx.len = src->len;
		qctx.last_status = src->last_status;
		qctx.data = src->data;
		return (handle_dollar_ctx_word(ctx, &qctx, i));
	}
	return (handle_regular_char(ctx, src->line, i));
}

/* <= 4 args: ctx + src + i */
int	process_chars_ctx(t_word_ctx *ctx, t_word_src *src, size_t *i)
{
	int	rc;

	while (*i < src->len && !is_space((char)src->line[*i])
		&& !is_operator((char)src->line[*i]))
	{
		rc = dispatch_char_ctx(ctx, src, i);
		if (rc != 0)
			return (rc);
	}
	return (0);
}

/*
void dbg_buf_print(const t_word_ctx *ctx)
{
	const char *d = ctx->buf.data ? ctx->buf.data : "(null)";
	fprintf(stderr, "[DBG] buf=\"%s\" seen_s=%d seen_d=%d seen_u=%d\n",
			d, ctx->seen_single, ctx->seen_double, ctx->seen_unquoted);
}

 Loop principal con trazas
int process_chars_ctx(t_word_ctx *ctx, const char *line,
							 size_t *i, size_t len, int last_status)
{
	int rc;
	fprintf(stderr, "[DBG] process_chars_ctx start i=%zu len=%zu\n", *i, len);
	while (*i < len && !is_space((char)line[*i]) &&
		   !is_operator((char)line[*i]))
	{
		rc = dispatch_char(ctx, line, i, len, last_status);
		if (rc != 0)
		{
			fprintf(stderr,
				"[DBG] process_chars_ctx returning rc=%d i=%zu\n", rc, *i);
			return (rc);
		}
	}
	fprintf(stderr, "[DBG] process_chars_ctx done i=%zu\n", *i);
	return (0);
}

*//* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expand.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/29 11:50:38 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/29 11:50:47 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

int	expand_special_status(t_buf *buf, size_t *i, int last_status)
{
	char	*s;
	int		rc;

	if (!buf || !i)
		return (-1);
	s = ft_itoa(last_status);
	if (!s)
		return (-1);
	rc = buf_append_str(buf, s);
	free(s);
	if (rc < 0)
		return (-1);
	(*i)++;
	return (0);
}

int	expand_special_pid(t_buf *buf, size_t *i)
{
	char	*s;
	int		rc;

	if (!buf || !i)
		return (-1);
	s = ft_itoa((int)getpid());
	if (!s)
		return (-1);
	rc = buf_append_str(buf, s);
	free(s);
	if (rc < 0)
		return (-1);
	(*i)++;
	return (0);
}

int	expand_dollar(t_expand_ctx *ctx, size_t *i)
{
	if (!ctx || !ctx->buf || !ctx->line || !i)
		return (-1);
	if (*i >= ctx->len || ctx->line[*i] != '$')
		return (0);
	(*i)++;
	if (*i >= ctx->len)
	{
		if (buf_append_char(ctx->buf, '$') < 0)
			return (-1);
		return (0);
	}
	if (ctx->line[*i] == '?')
		return (expand_special_status(ctx->buf, i, ctx->last_status));
	if (ctx->line[*i] == '$')
		return (expand_special_pid(ctx->buf, i));
	if (ctx->line[*i] == '{')
		return (handle_braced_ctx(ctx, i));
	return (handle_simple_ctx(ctx, i));
}

/* Wrapper con contexto para los llamadores existentes */
int	expand_dollar_ctx(t_quote_ctx *qctx, size_t *i)
{
	t_expand_ctx	ctx;

	if (!qctx || !i)
		return (-1);
	ctx.buf = qctx->buf;
	ctx.line = qctx->line;
	ctx.len = qctx->len;
	ctx.last_status = qctx->last_status;
	ctx.data = qctx->data;
	return (expand_dollar(&ctx, i));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokenizer.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/13 13:31:36 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/13 13:32:43 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

static int	append_operator_ctx(t_tokenizer_ctx *ctx, size_t *i, int had_space)
{
	t_token	*op;

	op = parse_operator(ctx->line, i, ctx->len);
	if (!op)
		return (0);
	set_prev_join_next(ctx->head, had_space);
	token_append(ctx->head, op);
	return (1);
}

static int	append_word_ctx(t_tokenizer_ctx *ctx, size_t *i, int had_space)
{
	t_word_src	src;
	t_token		*word;

	src.line = ctx->line;
	src.len = ctx->len;
	src.last_status = ctx->last_status;
	src.data = ctx->data;
	word = parse_word_ctx(&src, i);
	if (!word)
		return (0);
	set_prev_join_next(ctx->head, had_space);
	token_append(ctx->head, word);
	return (1);
}

static int	is_operator_char(char c)
{
	if (c == '<' || c == '>' || c == '|' || c == '&' || c == '(' || c == ')')
		return (1);
	return (0);
}

static int	process_one_token(t_tokenizer_ctx *ctx, size_t *i)
{
	int	had_space;

	had_space = skip_spaces_with_flag(ctx->line, i, ctx->len);
	if (*i >= ctx->len)
		return (1);
	if (is_operator_char(ctx->line[*i]))
		return (append_operator_ctx(ctx, i, had_space));
	return (append_word_ctx(ctx, i, had_space));
}

t_token	*tokenizer(const char *line, int last_status, t_data *data)
{
	t_tokenizer_ctx	ctx;
	t_token			*head;
	size_t			i;

	if (!line)
		return (NULL);
	ctx.line = line;
	ctx.len = ft_strlen(line);
	ctx.last_status = last_status;
	ctx.data = data;
	head = NULL;
	ctx.head = &head;
	i = 0;
	while (i < ctx.len)
	{
		if (!process_one_token(&ctx, &i))
		{
			free_tokens(head);
			return (NULL);
		}
	}
	return (head);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   process_chars_ctx_handlers.c                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/29 11:52:05 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/29 11:52:15 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

/*
int	dispatch_char(t_word_ctx *ctx, const char *line,
	size_t *i, size_t len, int last_status, t_data *data)
{
	char	c;

	c = line[*i];
	if (c == '\'')
		return (handle_single_quote(ctx, line, i, len));
	if (c == '"')
		return (handle_double_quote(ctx, line, i, len, last_status, data));
	if (c == '$')
		return (handle_dollar(ctx, line, i, len, last_status, data));
	return (handle_regular_char(ctx, line, i));
}
int	handle_backslash_outside(t_word_ctx *ctx,
	const char *line, size_t *i, size_t len)
{
	ctx->seen_unquoted = 1;
	(*i)++;
	if (*i < len)
	{
		if (buf_append_char(&ctx->buf, line[*i]) < 0)
			return (-3);
		(*i)++;
		return (0);
	}
	if (buf_append_char(&ctx->buf, '\\') < 0)
		return (-3);
	return (0);
}*/

int	handle_single_quote(t_word_ctx *ctx, const char *line,
	size_t *i, size_t len)
{
	if (!ctx || !line || !i)
		return (-1);
	ctx->seen_single = 1;
	ctx->was_quoted = 1;
	(*i)++;
	if (parse_single_quote(&ctx->buf, line, i, len) < 0)
		return (-1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   display_token_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/13 13:02:42 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/13 13:15:50 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

void	print_escaped_loop(const char *s)
{
	unsigned char	c;

	while (*s)
	{
		c = (unsigned char)*s;
		print_escaped_char(c);
		s++;
	}
}

void	print_null_token(size_t i)
{
	printf("token");
	printf("%zu", i + 1);
	printf(": (NULL)\n");
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   handle_brace_utils.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/29 11:51:32 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/29 11:51:40 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

size_t	parse_identifier_len(const char *line, size_t i, size_t len)
{
	size_t	n;
	char	c;

	if (!line || i >= len)
		return (0);
	if (!((line[i] >= 'A' && line[i] <= 'Z')
			|| (line[i] >= 'a' && line[i] <= 'z')
			|| (line[i] == '_')))
		return (0);
	n = 0;
	while (i + n < len)
	{
		c = line[i + n];
		if (!((c >= 'A' && c <= 'Z')
				|| (c >= 'a' && c <= 'z')
				|| (c >= '0' && c <= '9')
				|| (c == '_')))
			break ;
		n++;
	}
	return (n);
}

char	*ft_strndup(const char *s, size_t n)
{
	char	*out;

	if (!s)
		return (NULL);
	out = malloc(n + 1);
	if (!out)
		return (NULL);
	ft_memcpy(out, s, n);
	out[n] = '\0';
	return (out);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   signals.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelona.co  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/04 15:22:27 by jadelgad          #+#    #+#             */
/*   Updated: 2026/02/04 15:22:29 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#define _XOPEN_SOURCE 700
#include <signal.h>
#include <string.h>
#include "nanoshell.h"

volatile sig_atomic_t	g_signal_received = 0;

static void	signal_handler(int signum)
{
	if (signum == SIGINT)
	{
		write(1, "\n", 1);
		rl_replace_line("", 0);
		rl_on_new_line();
		rl_redisplay();
	}
	g_signal_received = signum;
}

/*
"Como readline es una función bloqueante, uso ioctl para simular un 'Enter' cuando llega un SIGINT.
 Esto despierta a readline inmediatamente, permitiendo que la shell recupere el control sin que el 
 usuario tenga que pulsar ninguna tecla extra."
*/

void	signal_handler_heredoc(int signum)
{
	if (signum == SIGINT)
	{
		g_signal_received = SIGINT;
		ioctl(STDIN_FILENO, TIOCSTI, "\n");
		write(1, "\n", 1);
	}
}

int	handle_signal_interrupt(t_data *data, char *line)
{
	if (g_signal_received == SIGINT)
	{
		data->last_status = 130;
		g_signal_received = 0;
		if (!line)
			return (1);
	}
	return (0);
}

void	setup_signals(void)
{
	struct sigaction	sa;

	ft_memset(&sa, 0, sizeof(sa));
	sa.sa_handler = signal_handler;
	sa.sa_flags = 0;
	sigemptyset(&sa.sa_mask);
	if (sigaction(SIGINT, &sa, NULL) == -1)
	{
		perror("sigaction SIGINT");
	}
	signal(SIGQUIT, SIG_IGN);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   run_multi_pipes.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/29 11:58:42 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/29 13:33:53 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

static void	parent_close_intermediates(int (*pipes)[2], int n)
{
	int	i;

	if (!pipes || n <= 1)
		return ;
	i = 0;
	while (i < n - 1)
	{
		if (pipes[i][0] >= 0)
		{
			close(pipes[i][0]);
			pipes[i][0] = -1;
		}
		if (pipes[i][1] >= 0)
		{
			close(pipes[i][1]);
			pipes[i][1] = -1;
		}
		i++;
	}
}

int	spawn_all_children(t_ast **cmds, int n, t_multi_ctx *ctx)
{
	int	i;
	int	in_fd;
	int	out_fd;

	if (!ctx || !cmds || n <= 0)
		return (-1);
	i = 0;
	while (i < n)
	{
		in_fd = -1;
		out_fd = -1;
		if (i > 0)
			in_fd = ctx->pipes[i - 1][0];
		if (i < n - 1)
			out_fd = ctx->pipes[i][1];
		ctx->pids[i] = spawn_child(cmds[i], in_fd, out_fd, ctx->data);
		if (ctx->pids[i] == -1)
			return (-1);
		i++;
	}
	return (0);
}

int	create_pipes(int (*pipes)[2], int n)
{
	int	i;
	int	j;

	i = 0;
	while (i < n - 1)
	{
		while (pipe(pipes[i]) == -1)
		{
			if (errno == EINTR)
				continue ;
			j = 0;
			while (j < i)
			{
				if (pipes[j][0] >= 0)
					close(pipes[j][0]);
				if (pipes[j][1] >= 0)
					close(pipes[j][1]);
				j++;
			}
			return (-1);
		}
		i++;
	}
	return (0);
}

int	allocate_resources(int n, int (*(*pipes_out))[2], pid_t **pids_out)
{
	int		(*pipes)[2];
	pid_t	*pids;
	int		i;

	pipes = safe_malloc(sizeof(int [2]) * (n - 1));
	pids = safe_malloc(sizeof(pid_t) * n);
	i = 0;
	while (i < n - 1)
	{
		pipes[i][0] = -1;
		pipes[i][1] = -1;
		i++;
	}
	i = 0;
	while (i < n)
	{
		pids[i] = 0;
		i++;
	}
	*pipes_out = pipes;
	*pids_out = pids;
	return (0);
}

int	run_multi(t_ast **cmds, int n, t_data *data)
{
	int			(*pipes)[2];
	pid_t		*pids;
	int			status;
	t_multi_ctx	ctx;

	if (n < 2)
		return (run_single(cmds[0], data));
	if (setup_resources(n, &pipes, &pids, data) == -1)
		return (127);
	ctx.pipes = pipes;
	ctx.pids = pids;
	ctx.data = data;
	if (spawn_children_checked(cmds, n, &ctx) == -1)
	{
		teardown_resources(pipes, pids, n, data);
		return (127);
	}
	parent_close_intermediates(pipes, n);
	status = wait_for_all(pids, n);
	teardown_resources(pipes, pids, n, data);
	return (status);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipe_utils.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/29 11:58:13 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/29 11:58:17 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

pid_t	wait_one(pid_t pid, int *st)
{
	pid_t	w;

	if (pid <= 0 || st == NULL)
		return (-1);
	w = waitpid(pid, st, 0);
	while (w == -1 && errno == EINTR)
	{
		w = waitpid(pid, st, 0);
	}
	return (w);
}

int	status_to_code(int s)
{
	if (WIFEXITED(s))
		return (WEXITSTATUS(s));
	if (WIFSIGNALED(s))
		return (128 + WTERMSIG(s));
	return (s);
}

int	spawn_children_checked(t_ast **cmds, int n, t_multi_ctx *ctx)
{
	if (!ctx)
		return (-1);
	if (spawn_all_children(cmds, n, ctx) == -1)
	{
		wait_for_all(ctx->pids, n);
		close_all_pipes(ctx->pipes, n);
		return (-1);
	}
	return (0);
}

int	setup_resources(int n, int (*(*pipes_out))[2],
	pid_t **pids_out, t_data *data)
{
	int		(*pipes)[2];
	pid_t	*pids;

	if (allocate_resources(n, &pipes, &pids) == -1)
		return (-1);
	if (data)
	{
		data->pipes = pipes;
		data->pipes_count = n;
	}
	if (create_pipes(pipes, n) == -1)
	{
		close_all_pipes(pipes, n);
		free(pids);
		free(pipes);
		if (data)
		{
			data->pipes = NULL;
			data->pipes_count = 0;
		}
		return (-1);
	}
	*pipes_out = pipes;
	*pids_out = pids;
	return (0);
}

void	teardown_resources(int (*pipes)[2], pid_t *pids, int n, t_data *data)
{
	if (pids)
		free(pids);
	if (pipes)
	{
		close_all_pipes(pipes, n);
		free(pipes);
	}
	if (data)
	{
		data->pipes = NULL;
		data->pipes_count = 0;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_command.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/29 11:58:42 by jadelgad          #+#    #+#             */
/*   Updated: 2026/02/11 13:41:53 by alemonto         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

// Formato: "bash: line 1: <cmd>: <msg>\n"
int	wait_for_child(pid_t pid)
{
	int		status;
	int		ret;
	pid_t	w;

	while (1)
	{
		w = waitpid(pid, &status, 0);
		if (w == -1)
		{
			if (errno == EINTR)
				continue ;
			perror("waitpid");
			return (127);
		}
		break ;
	}
	if (WIFEXITED(status))
		return (WEXITSTATUS(status));
	ret = 128 + WTERMSIG(status);
	if (WTERMSIG(status) == SIGINT)
		write(1, "\n", 1);
	else if (WTERMSIG(status) == SIGQUIT)
		write(1, "Quit (core dumped)\n", 19);
	return (ret);
}

void	reset_sig_in_child(void)
{
	signal(SIGINT, SIG_DFL);
	signal(SIGQUIT, SIG_DFL);
}

void	exec_child(t_ast *node, t_data *data)
{
	char	**env;
	char	*path;
	t_ast	*cmd;

	reset_sig_in_child();
	data->pid = 1;
	if (apply_all_redirections(node) == -1)
		exit(1);
	cmd = get_core_node(node);
	if (!cmd || !cmd->argv || !cmd->argv[0])
		exit(0);
	env = prepare_env(cmd, data);
	if (is_builtin(cmd->argv[0]))
		exec_child_builtin(cmd, data, env);
	path = find_path((char *)cmd->argv[0], env);
	if (!path)
	{
		bash_style_error(cmd->argv[0], "command not found");
		if (env != data->envp)
			free_env(env);
		exit(127);
	}
	execve(path, cmd->argv, env);
	handle_exec_error(cmd->argv[0], path, env, data);
}

static int	exec_builtin_parent(t_ast *node, t_data *data)
{
	t_ast	*core;
	int		save_fds[2];
	int		status;

	core = get_core_node(node);
	if (!core || !core->argv)
		return (0);
	save_fds[0] = dup(STDIN_FILENO);
	save_fds[1] = dup(STDOUT_FILENO);
	if (apply_all_redirections(node) == -1)
	{
		dup2(save_fds[0], STDIN_FILENO);
		dup2(save_fds[1], STDOUT_FILENO);
		return (close(save_fds[0]), close(save_fds[1]), 1);
	}
	status = call_builtin(core->argv, data);
	dup2(save_fds[0], STDIN_FILENO);
	dup2(save_fds[1], STDOUT_FILENO);
	close(save_fds[0]);
	close(save_fds[1]);
	return (status);
}

int	exec_command(t_ast *node, t_data *data)
{
	pid_t	pid;

	if (!node || !data)
		return (127);
	if (node->argv && node->argv[0] && is_builtin(node->argv[0])
		&& builtin_should_run_in_parent(node->argv[0]))
		return (exec_builtin_parent(node, data));
	pid = fork();
	if (pid < 0)
		return (perror("fork"), 127);
	if (pid == 0)
		exec_child(node, data);
	return (wait_for_child(pid));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_ast.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/29 11:54:31 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/29 15:25:45 by alemonto         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

static int	exec_or(t_ast *node, t_data *data)
{
	int	status;

	if (!node || node->type != AST_OR)
		return (1);
	status = exec_ast(node->left, data);
	if (status != 0)
		return (exec_ast(node->right, data));
	return (status);
}

static int	exec_and(t_ast *node, t_data *data)
{
	int	status;

	if (!node || node->type != AST_AND)
		return (1);
	status = exec_ast(node->left, data);
	if (status == 0)
		return (exec_ast(node->right, data));
	return (status);
}

int	exec_ast_in_child(t_ast *node, t_data *data)
{
	int	status;

	if (!node)
		return (0);
	if (node->type == AST_COMMAND || node->type == AST_REDIRECT)
	{
		exec_child(node, data);
		exit(data->last_status);
	}
	else if (node->type == AST_AND)
		status = exec_and(node, data);
	else if (node->type == AST_OR)
		status = exec_or(node, data);
	else if (node->type == AST_PIPE)
		status = exec_pipeline(node, data);
	else if (node->type == AST_SUBSHELL)
		status = exec_subshell(node, data);
	else
		status = 1;
	return (status);
}

int	exec_ast(t_ast *node, t_data *data)
{
	int	status;

	if (!node)
		return (0);
	if (node->type == AST_COMMAND || node->type == AST_REDIRECT)
		status = exec_command(node, data);
	else if (node->type == AST_AND)
		status = exec_and(node, data);
	else if (node->type == AST_OR)
		status = exec_or(node, data);
	else if (node->type == AST_PIPE)
		status = exec_pipeline(node, data);
	else if (node->type == AST_SUBSHELL)
		status = exec_subshell(node, data);
	else
		status = 1;
	unlink_heredocs(node);
	data->last_status = status;
	return (status);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_utils.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelona.co  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/04 15:18:42 by jadelgad          #+#    #+#             */
/*   Updated: 2026/02/04 15:18:44 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

void	exec_error(const char *message, const char *subject)
{
	const char	*prefix;
	const char	*err;

	prefix = "minishell: ";
	write(2, prefix, ft_strlen_const(prefix));
	if (subject)
		write(2, subject, ft_strlen_const(subject));
	if (message && ft_strncmp(message, "command not found", 18) == 0)
	{
		write(2, ": command not found\n", 21);
		return ;
	}
	write(2, ": ", 2);
	if (errno != 0)
	{
		err = strerror(errno);
		if (err)
			write(2, err, ft_strlen_const(err));
		write(2, "\n", 1);
		return ;
	}
	if (message)
		write(2, message, ft_strlen_const(message));
	write(2, "\n", 1);
}

char	*heredoc_tmp_name(void)
{
	static int	n;
	char		*num;
	char		*name;

	if (n < 0)
		n = 0;
	num = ft_itoa(n);
	if (!num)
		return (NULL);
	n++;
	name = ft_strjoin(".heredoc_", num);
	free(num);
	return (name);
}

static int	is_delim(char *line, char *delimiter)
{
	size_t	len;

	if (!line)
		return (0);
	len = ft_strlen(delimiter);
	if (ft_strlen(line) == len && ft_strncmp(line, delimiter, len) == 0)
		return (1);
	return (0);
}

/*
** Returns 0 on success (EOF or delimiter found)
** Returns -1 if interrupted by SIGINT
*/

static int	write_heredoc_loop(int fd, char *delimiter)
{
	char	*line;
	int		status;

	status = 0;
	signal(SIGINT, signal_handler_heredoc);
	while (1)
	{
		line = readline("> ");
		if (g_signal_received == SIGINT)
		{
			if (line)
				free(line);
			status = -1;
			break ;
		}
		if (!line)
			break ;
		if (is_delim(line, delimiter))
		{
			free(line);
			break ;
		}
		write(fd, line, ft_strlen(line));
		write(fd, "\n", 1);
		free(line);
	}
	setup_signals();
	return (status);
}

char	*create_heredoc_tmp(char *delimiter)
{
	char	*path;
	int		fd;

	path = heredoc_tmp_name();
	if (!path)
		return (NULL);
	fd = open(path, O_WRONLY | O_CREAT | O_TRUNC, 0600);
	if (fd < 0)
	{
		exec_error("open failed", path);
		free(path);
		return (NULL);
	}
	if (write_heredoc_loop(fd, delimiter) == -1)
	{
		close(fd);
		unlink(path);
		free(path);
		return (NULL);
	}
	close(fd);
	return (path);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_redir.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelona.co  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/04 15:18:22 by jadelgad          #+#    #+#             */
/*   Updated: 2026/02/04 15:18:25 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

static t_ast	*collect_redirs(t_ast *node, t_ast ***reds, int *n)
{
	t_ast	*tmp;
	int		i;

	tmp = node;
	*n = 0;
	while (tmp && tmp->type == AST_REDIRECT)
	{
		(*n)++;
		tmp = tmp->left;
	}
	if (*n == 0)
		return (tmp);
	*reds = safe_malloc((*n) * sizeof(t_ast *));
	tmp = node;
	i = 0;
	while (i < *n)
	{
		(*reds)[i++] = tmp;
		tmp = tmp->left;
	}
	return (tmp);
}

void	apply_redirect_and_exec_child(t_ast *node, t_data *data)
{
	t_ast	*child;
	t_ast	**reds;
	int		n;

	if (!node)
		exit(1);
	n = 0;
	reds = NULL;
	child = collect_redirs(node, &reds, &n);
	if (reds)
	{
		if (execute_redirection_list(reds, n) == -1)
		{
			free(reds);
			exit(1);
		}
		free(reds);
	}
	if (!child)
		exit(0);
	if (child->type == AST_COMMAND)
		exec_child(child, data);
	else
		exec_ast_in_child(child, data);
	exit(127);
}

int	apply_all_redirections(t_ast *node)
{
	t_ast	**reds;
	int		n;
	int		status;

	reds = NULL;
	n = 0;
	collect_redirs(node, &reds, &n);
	if (!reds)
		return (0);
	status = execute_redirection_list(reds, n);
	free(reds);
	return (status);
}

void	unlink_heredocs(t_ast *node)
{
	while (node && node->type == AST_REDIRECT)
	{
		if (node->redirect_type == TOKEN_HEREDOC && node->file)
			unlink(node->file);
		node = node->left;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_pipeline.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/29 11:55:29 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/29 11:55:32 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

static int	fill_children(t_ast_list *children, t_ast **ar)
{
	int	i;

	i = 0;
	if (!ar)
		return (-1);
	while (children)
	{
		ar[i++] = children->node;
		children = children->next;
	}
	return (0);
}

static t_ast	**alloc_children(int n)
{
	if (n <= 0)
		return (NULL);
	return (safe_malloc(sizeof(t_ast *) * n));
}

static int	count_children(t_ast_list *children)
{
	int	n;

	n = 0;
	while (children)
	{
		n++;
		children = children->next;
	}
	return (n);
}

static int	collect_children(t_ast_list *children, t_ast ***out_array)
{
	int	n;

	if (!out_array)
		return (-1);
	n = count_children(children);
	if (n == 0)
	{
		*out_array = NULL;
		return (0);
	}
	*out_array = alloc_children(n);
	if (!*out_array)
		return (-1);
	if (fill_children(children, *out_array) == -1)
	{
		free(*out_array);
		*out_array = NULL;
		return (-1);
	}
	return (n);
}

int	exec_pipeline(t_ast *node, t_data *data)
{
	t_ast	**cmds;
	int		n;
	int		status;

	if (!node || !data || !node->children)
		return (0);
	cmds = NULL;
	status = 0;
	n = collect_children(node->children, &cmds);
	if (n < 0)
		return (127);
	if (n == 0)
		return (0);
	if (n == 1)
		status = run_single(cmds[0], data);
	else
		status = run_multi(cmds, n, data);
	free(cmds);
	return (status);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   run_pipeline.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/29 11:59:11 by jadelgad          #+#    #+#             */
/*   Updated: 2025/12/03 13:19:29 by alemonto         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

pid_t	spawn_child(t_ast *cmd, int in_fd, int out_fd, t_data *data)
{
	pid_t	pid;

	pid = fork();
	if (pid < 0)
		return (-1);
	if (pid == 0)
	{
		reset_sig_in_child();
		setup_child_io(data, in_fd, out_fd);
		run_child_and_exit(cmd, data);
	}
	return (pid);
}

int	run_single(t_ast *cmd, t_data *data)
{
	if ((!cmd->argv || !cmd->argv[0]) && cmd->assignments)
	{
		apply_assignments_array(&data->envp, cmd->assignments);
		return (0);
	}
	return (exec_command(cmd, data));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   spawn_child_helpers.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/29 11:59:11 by jadelgad          #+#    #+#             */
/*   Updated: 2025/12/03 13:19:29 by alemonto         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

static void	close_unused_pipe_fd(int (*pipes)[2], int n,
	int keep_in_fd, int keep_out_fd)
{
	int	i;

	if (!pipes || n <= 1)
		return ;
	i = 0;
	while (i < n - 1)
	{
		if (pipes[i][0] >= 0 && pipes[i][0] != keep_in_fd)
			close(pipes[i][0]);
		if (pipes[i][1] >= 0 && pipes[i][1] != keep_out_fd)
			close(pipes[i][1]);
		i++;
	}
}

void	setup_child_io(t_data *data, int in_fd, int out_fd)
{
	reset_sig_in_child();
	if (data)
		close_unused_pipe_fd(data->pipes, data->pipes_count, in_fd, out_fd);
	if (in_fd != -1)
	{
		if (dup2(in_fd, STDIN_FILENO) == -1)
			exit(127);
	}
	if (out_fd != -1)
	{
		if (dup2(out_fd, STDOUT_FILENO) == -1)
			exit(127);
	}
	if (in_fd != -1 && in_fd != STDIN_FILENO)
		close(in_fd);
	if (out_fd != -1 && out_fd != STDOUT_FILENO)
		close(out_fd);
}

static void	exec_external_and_exit(t_ast *cmd)
{
	char	*path;

	if (!cmd || !cmd->argv || !cmd->argv[0])
		exit(127);
	path = find_path((char *)cmd->argv[0], NULL);
	if (!path)
	{
		exec_error("command not found", cmd->argv[0]);
		exit(127);
	}
	execve(path, cmd->argv, NULL);
	if (errno == EACCES)
		exec_error("permission denied", cmd->argv[0]);
	else
		exec_error("execve failed", cmd->argv[0]);
	free(path);
	if (errno == EACCES)
		exit(126);
	else
		exit(127);
}

void	run_child_and_exit(t_ast *cmd, t_data *data)
{
	int	status;

	if (data)
	{
		if (cmd->type == AST_REDIRECT)
		{
			apply_redirect_and_exec_child(cmd, data);
			exit(1);
		}
		status = exec_ast_in_child(cmd, data);
		exit(status);
	}
	exec_external_and_exit(cmd);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_subshell.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelona.co  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/04 15:18:33 by jadelgad          #+#    #+#             */
/*   Updated: 2026/02/04 15:18:35 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

int	exec_subshell(t_ast *node, t_data *data)
{
	pid_t	pid;
	int		status;

	if (!node || node->type != AST_SUBSHELL || !node->left)
		return (1);
	pid = fork();
	if (pid < 0)
	{
		perror("fork");
		return (1);
	}
	if (pid == 0)
	{
		reset_sig_in_child();
		status = exec_ast(node->left, data);
		exit(status);
	}
	return (wait_for_child(pid));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   find_path.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/29 11:56:13 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/29 11:56:18 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

static char	*join_dir_cmd(const char *dir, const char *cmd)
{
	size_t	dir_len;
	size_t	cmd_len;
	size_t	add_slash;
	size_t	need;
	char	*out;

	if (!calc_need_and_slash(dir, cmd, &need, &add_slash))
		return (NULL);
	dir_len = ft_strlen(dir);
	cmd_len = ft_strlen(cmd);
	out = malloc(need);
	if (!out)
		return (NULL);
	if (dir_len > 0)
		ft_memcpy(out, dir, dir_len);
	if (add_slash)
		out[dir_len] = '/';
	ft_memcpy(out + dir_len + add_slash, cmd, cmd_len);
	out[dir_len + add_slash + cmd_len] = '\0';
	return (out);
}

int	try_path_segment(const char *seg, const char *cmd, char **out)
{
	char		*candidate;
	const char	*dir;

	if (!seg || !cmd || !out)
		return (0);
	if (*seg == '\0')
		dir = ".";
	else
		dir = seg;
	candidate = join_dir_cmd(dir, cmd);
	if (!candidate)
		return (0);
	if (access(candidate, X_OK) == 0)
	{
		*out = candidate;
		return (1);
	}
	free(candidate);
	return (0);
}

static char	*search_path_segments(const char *path, const char *cmd)
{
	const char		*cur;
	char			*res;
	t_path_range	rng;
	int				rc;

	if (!path || !cmd)
		return (NULL);
	cur = path;
	while (1)
	{
		rng = (t_path_range){path, (size_t)(cur - path), 0};
		while (*cur && *cur != ':')
			cur++;
		rng.end = (size_t)(cur - path);
		rc = try_path_range(rng, cmd, &res);
		if (rc == 1)
			return (res);
		if (*cur == '\0')
			return (NULL);
		cur++;
	}
	return (NULL);
}

static char	*get_envp_path(char **envp)
{
	int	i;

	if (!envp)
		return (NULL);
	i = 0;
	while (envp[i])
	{
		if (ft_strncmp(envp[i], "PATH=", 5) == 0)
			return (envp[i] + 5);
		i++;
	}
	return (NULL);
}

char	*find_path(char *cmd, char **envp)
{
	char	*path;

	if (!cmd || !*cmd)
		return (NULL);
	if (ft_strchr(cmd, '/'))
	{
		if (access(cmd, X_OK) == 0)
			return (ft_strdup(cmd));
		return (NULL);
	}
	path = get_envp_path(envp);
	if (!path)
		return (NULL);
	return (search_path_segments(path, cmd));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   find_path_helper.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/29 11:57:22 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/29 11:57:25 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

int	calc_need_and_slash(const char *dir, const char *cmd,
	size_t *need, size_t *add_slash)
{
	size_t	dir_len;
	size_t	cmd_len;

	if (!dir || !cmd || !need || !add_slash)
		return (0);
	dir_len = ft_strlen(dir);
	cmd_len = ft_strlen(cmd);
	if (dir_len == 0)
		*add_slash = 1;
	else if (dir[dir_len - 1] == '/')
		*add_slash = 0;
	else
		*add_slash = 1;
	if (cmd_len > SIZE_MAX - dir_len - *add_slash - 1)
		return (0);
	*need = dir_len + *add_slash + cmd_len + 1;
	return (1);
}

int	try_path_range(t_path_range range, const char *cmd, char **res)
{
	char	*seg;
	int		ok;

	if (!range.path || !cmd || !res)
		return (0);
	if (range.end == range.start)
	{
		if (try_path_segment("", cmd, res))
			return (1);
		return (0);
	}
	seg = ft_strndup(range.path + range.start, range.end - range.start);
	if (!seg)
		return (-1);
	ok = try_path_segment(seg, cmd, res);
	free(seg);
	if (ok)
		return (1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_command_helpers.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/29 11:58:42 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/29 13:33:53 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

void	exec_child_builtin(t_ast *node, t_data *data, char **env)
{
	int	status;

	reset_sig_in_child();
	status = call_builtin(node->argv, data);
	if (env != data->envp)
		free_env(env);
	exit(status);
}

void	bash_style_error(const char *cmd, const char *msg)
{
	if (!cmd || !msg)
		return ;
	write(2, "bash: line 1: ", 14);
	write(2, cmd, ft_strlen_const(cmd));
	write(2, ": ", 2);
	write(2, msg, ft_strlen_const(msg));
	write(2, "\n", 1);
}

t_ast	*get_core_node(t_ast *node)
{
	t_ast	*curr;

	curr = node;
	while (curr && curr->type == AST_REDIRECT)
		curr = curr->left;
	return (curr);
}

char	**prepare_env(t_ast *node, t_data *data)
{
	char	**env;

	env = data->envp;
	if (node->assignments && node->assignments[0])
	{
		env = dup_env(data->envp);
		if (!env)
			exit(1);
		apply_assignments_array(&env, node->assignments);
	}
	return (env);
}

void	handle_exec_error(char *cmd, char *path, char **env, t_data *data)
{
	int	exit_code;

	exit_code = 127;
	if (errno == EACCES || errno == ENOEXEC)
	{
		bash_style_error(cmd, strerror(errno));
		exit_code = 126;
	}
	else if (errno != 0)
		bash_style_error(cmd, strerror(errno));
	if (path)
		free(path);
	if (env != data->envp)
		free_env(env);
	exit(exit_code);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipe_helpers.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/29 11:56:48 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/29 11:56:55 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

void	close_all_pipes(int (*pipes)[2], int n)
{
	int	i;

	i = 0;
	if (!pipes || n <= 0)
	{
		return ;
	}
	while (i < n - 1)
	{
		if (pipes[i][0] >= 0)
		{
			close(pipes[i][0]);
			pipes[i][0] = -1;
		}
		if (pipes[i][1] >= 0)
		{
			close(pipes[i][1]);
			pipes[i][1] = -1;
		}
		i++;
	}
}

int	wait_for_all(pid_t *pids, int count)
{
	int		i;
	int		last;
	int		status;
	pid_t	w;

	if (!pids || count <= 0)
		return (0);
	i = 0;
	last = 0;
	while (i < count)
	{
		if (pids[i] > 0)
		{
			w = wait_one(pids[i], &status);
			if (w == -1)
				last = 127;
			else
				last = status_to_code(status);
		}
		i++;
	}
	return (last);
}
/*
static ssize_t write_all(int fd, const void *buf, size_t count)
{
	const char *p;
	ssize_t     total;
	ssize_t     w;

	p = (const char *)buf;
	total = 0;
	while ((size_t)total < count)
	{
		w = write(fd, p + (size_t)total, count - (size_t)total);
		if (w == 0)
			return (-1);
		if (w == -1)
		{
			if (errno == EINTR)
				continue;
			return (-1);
		}
	total += w;
	}
	return (total);
}
static ssize_t  safe_read(int fd, void *buf, size_t count)
{
	ssize_t r;

	while (1)
	{
		r = read(fd, buf, count);
		if (r == -1)
		{
			if (errno == EINTR)
				continue;
			return (-1);
		}
		return (r);
	}
}


int forward_fd(int fd)   ESTO ERA UTIL PARA RUN_SINGLE, NOW IS TRASH
{
	char    buf[4096];
	ssize_t r;

	if (fd < 0)
		return (-1);
	while ((r = safe_read(fd, buf, sizeof(buf))) > 0)
	{
		if (write_all(STDOUT_FILENO, buf, (size_t)r) == -1)
		{
			close(fd);
			return (-1);
		}
	}
	if (r == -1)
	{
		close(fd);
		return (-1);
	}
	close(fd);
	return (0);
}
*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_redir.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelona.co  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/04 15:18:22 by jadelgad          #+#    #+#             */
/*   Updated: 2026/02/04 15:18:25 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

int	open_redirect(t_ast *redir)
{
	int	fd;

	fd = -1;
	if (redir->redirect_type == TOKEN_REDIR_OUT)
		fd = open(redir->file, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	else if (redir->redirect_type == TOKEN_REDIR_APPEND)
		fd = open(redir->file, O_WRONLY | O_CREAT | O_APPEND, 0644);
	else if (redir->redirect_type == TOKEN_REDIR_IN
		|| redir->redirect_type == TOKEN_HEREDOC)
		fd = open(redir->file, O_RDONLY);
	if (fd < 0)
	{
		ft_putstr_fd(redir->file, 2);
		ft_putstr_fd(": ", 2);
		ft_putstr_fd(strerror(errno), 2);
		return (-1);
	}
	return (fd);
}

int	execute_redirection_list(t_ast **reds, int n)
{
	int	fd;
	int	i;

	i = n - 1;
	while (i >= 0)
	{
		fd = open_redirect(reds[i]);
		if (fd < 0)
			return (-1);
		if (dup2(fd, reds[i]->redirect_fd) < 0)
		{
			exec_error("dup2 failed", reds[i]->file);
			close(fd);
			return (-1);
		}
		if (fd != reds[i]->redirect_fd)
			close(fd);
		i--;
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   get_next_line.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelona.co  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/04 15:18:55 by jadelgad          #+#    #+#             */
/*   Updated: 2026/02/04 15:18:57 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

static char	*read_and_append(int fd, char *stash)
{
	char	buffer[BUFFER_SIZE + 1];
	char	*temp;
	ssize_t	bytes_read;

	while (!stash || !(ft_strchr(stash, '\n')))
	{
		bytes_read = read(fd, buffer, BUFFER_SIZE);
		if (bytes_read < 0)
			return (NULL);
		if (bytes_read == 0)
			break ;
		buffer[bytes_read] = '\0';
		temp = ft_strjoin(stash, buffer);
		if (!temp)
		{
			free(stash);
			return (NULL);
		}
		stash = temp;
	}
	return (stash);
}

static char	*extract_line(char *stash)
{
	char	*line;
	ssize_t	len;

	if (!stash || !stash[0])
		return (NULL);
	if (!ft_strchr(stash, '\n'))
		len = ft_strlen(stash);
	else
		len = (ft_strchr(stash, '\n') - stash) + 1;
	line = ft_substr(stash, 0, len);
	if (!line)
		return (NULL);
	return (line);
}

static char	*update_stash(char *stash)
{
	char	*updated_stash;
	char	*pos;
	ssize_t	start;
	ssize_t	left;

	if (!stash || !stash[0])
		return (NULL);
	if (!ft_strchr(stash, '\n'))
	{
		free(stash);
		return (NULL);
	}
	pos = (ft_strchr(stash, '\n'));
	start = ((pos - stash) + 1);
	left = ft_strlen(stash) - start;
	updated_stash = ft_substr(stash, start, left);
	free(stash);
	if (!updated_stash || updated_stash[0] == '\0')
	{
		free(updated_stash);
		return (NULL);
	}
	return (updated_stash);
}

char	*get_next_line(int fd)
{
	static char	*stash;
	char		*line;

	if (fd < 0 || BUFFER_SIZE <= 0)
		return (NULL);
	stash = read_and_append(fd, stash);
	if (!stash)
		return (NULL);
	line = extract_line(stash);
	if (!line)
	{
		free(stash);
		stash = NULL;
		return (NULL);
	}
	if (ft_strchr(stash, '\n'))
		stash = update_stash(stash);
	else
	{
		free(stash);
		stash = NULL;
	}
	return (line);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   unset.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelona.co  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/04 15:15:53 by jadelgad          #+#    #+#             */
/*   Updated: 2026/02/04 15:39:16 by alemonto         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

static void	remove_env_var(t_data *data, int pos)
{
	char	**new_env;
	int		size;
	int		i;
	int		j;

	if (!data->envp)
		return ;
	size = 0;
	while (data->envp[size])
		size++;
	new_env = safe_malloc(size * sizeof(char *));
	i = 0;
	j = 0;
	while (i < size)
	{
		if (i == pos)
			free(data->envp[i]);
		else
			new_env[j++] = data->envp[i];
		i++;
	}
	new_env[j] = NULL;
	free(data->envp);
	data->envp = new_env;
}

int	builtin_unset(char **argv, t_data *data)
{
	int	i;
	int	pos;
	int	status;

	if (!argv || !argv[1] || !data)
		return (0);
	status = 0;
	i = 1;
	while (argv[i])
	{
		if (!is_valid_identifier(argv[i]))
		{
			builtin_error("unset", argv[i], "not a valid identifier");
			status = 1;
		}
		else
		{
			pos = find_name(data->envp, argv[i]);
			if (pos >= 0)
				remove_env_var(data, pos);
		}
		i++;
	}
	return (status);
}

/*
// basically copy all the envp with the same size and then i 
// go thru it and delete the one at the found position correct
// so u re-arrange it
int	builtin_unset(char **argv, t_data *data)
{
	int		status;
	int		i;
	int		pos;
	int		old_i;
	int		new_i;
	int		old_size;
	char	*name;
	char	**new_env;

	if (!argv || !argv[1] || !data)
		return (1);
	i = 1; // 0 is unset
	status = 0;
	while (argv[i]) // for multiple ones
	{
		name = argv[i];
		if (!is_valid_identifier(name))
		{
			builtin_error("unset", name, "not a valid identidier");
		//status = 1;
			i++;
			continue ;
		}
		pos = find_name(data->envp, name);
		if (pos >= 0)
		{
			old_size = 0;
			while (data->envp[old_size])
				old_size++;
			new_env = safe_malloc(old_size * sizeof(char *));
			old_i = 0;
			new_i = 0;
			while (old_i < old_size)
			{
				if (old_i == pos)
					free(data->envp[old_i]);
				else
				{
					new_env[new_i] = data->envp[old_i];
					new_i++;
				}
				old_i++;
			}
			new_env[new_i] = NULL;
			free(data->envp); // frees pointer array only
			data->envp = new_env;
		}
		i++;
	}
	return (status);
}

*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   echo_pwd_env.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/08 15:51:26 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/12 15:09:49 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

int	builtin_env(char **argv, t_data *data)
{
	int	i;

	(void)data;
	if (argv && argv[1])
	{
		ft_putstr_fd("env: no arguments supported\n", 2);
		return (1);
	}
	if (!data || !data->envp)
		return (0);
	i = 0;
	while (data->envp[i])
	{
		ft_putstr_fd(data->envp[i], 1);
		ft_putstr_fd("\n", 1);
		i++;
	}
	return (0);
}

int	builtin_pwd(char **argv, t_data *data)
{
	char	*cwd;

	(void)argv;
	(void)data;
	cwd = getcwd(NULL, 0);
	if (!cwd)
	{
		perror("pwd");
		return (1);
	}
	ft_putstr_fd(cwd, 1);
	ft_putstr_fd("\n", 1);
	free(cwd);
	return (0);
}

static int	is_n_flag(const char *s)
{
	int	i;

	i = 1;
	if (!s || s[0] != '-' || s[1] == '\0')
		return (0);
	while (s[i])
	{
		if (s[i] != 'n')
			return (0);
		i++;
	}
	return (1);
}

int	builtin_echo(char **argv, t_data *data)
{
	int	i;
	int	no_n;

	(void)data;
	i = 1;
	no_n = 0;
	while (argv && argv[i] && is_n_flag(argv[i]))
	{
		no_n = 1;
		i++;
	}
	while (argv && argv[i])
	{
		ft_putstr_fd(argv[i], 1);
		if (argv[i + 1])
			ft_putstr_fd(" ", 1);
		i++;
	}
	if (!no_n)
		ft_putstr_fd("\n", 1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils_helper_cd.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelona.co  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/04 15:16:18 by jadelgad          #+#    #+#             */
/*   Updated: 2026/02/04 15:16:21 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

char	*copy_home_and_rest(const char *home, const char *path)
{
	size_t	home_len;
	size_t	path_len;
	size_t	rest;
	size_t	need;
	char	*res;

	if (!home || !path)
		return (NULL);
	home_len = ft_strlen(home);
	path_len = ft_strlen(path);
	if (path_len > 1)
		rest = path_len - 1;
	else
		rest = 0;
	need = home_len + rest + 1;
	res = malloc(need);
	if (!res)
		return (NULL);
	ft_memcpy(res, home, home_len);
	if (rest > 0)
		ft_memcpy(res + home_len, path + 1, rest);
	res[home_len + rest] = '\0';
	return (res);
}

char	*expand_home(const char *path, t_data *data)
{
	const char	*home;

	if (!path)
		return (NULL);
	if (path[0] != '~')
		return (ft_strdup(path));
	home = get_var_from_envp(data->envp, "HOME");
	if (!home)
	{
		ft_putstr_fd("cd: HOME not set\n", 2);
		return (NULL);
	}
	return (copy_home_and_rest(home, path));
}

char	*resolve_cd_target(char **argv, t_data *data)
{
	char	*raw;
	char	*expanded;

	raw = get_raw_cd_target(argv, data);
	if (!raw)
		return (NULL);
	if (raw[0] == '\0')
	{
		free(raw);
		expanded = expand_home("~", data);
		return (expanded);
	}
	expanded = expand_home(raw, data);
	free(raw);
	return (expanded);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtin_exit.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/29 11:52:54 by jadelgad          #+#    #+#             */
/*   Updated: 2026/02/11 13:36:30 by alemonto         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

static int	parse_and_set_code(const char *arg, t_data *data)
{
	long	val;
	int		exit_code;

	val = ft_atoi(arg);
	exit_code = (int)((unsigned char)val);
	if (data)
	{
		data->last_status = exit_code;
		data->running = 1;
	}
	return (exit_code);
}

static int	is_numeric_arg(const char *s)
{
	int	i;

	if (!s)
		return (0);
	i = 0;
	if (s[0] == '+' || s[0] == '-')
		i = 1;
	if (s[i] == '\0')
		return (0);
	while (s[i])
	{
		if (!ft_isdigit((unsigned char)s[i]))
			return (0);
		i++;
	}
	return (1);
}

static int	handle_no_numeric_arg(t_data *data, const char *arg)
{
	ft_putstr_fd("exit: ", 2);
	if (arg)
		ft_putstr_fd((char *)arg, 2);
	ft_putstr_fd(": numeric argument required\n", 2);
	if (data)
	{
		data->last_status = 255;
		data->running = 1;
		return (255);
	}
	return (255);
}

static int	handle_no_args(t_data *data)
{
	if (data)
	{
		data->running = 1;
		return (data->last_status);
	}
	return (0);
}

int	builtin_exit(char **argv, t_data *data)
{
	if (data->pid == 0)
		ft_putendl_fd("exit", 2);
	if (!argv || !argv[1])
		return (handle_no_args(data));
	if (!is_numeric_arg(argv[1]))
		return (handle_no_numeric_arg(data, argv[1]));
	if (argv[2])
	{
		ft_putstr_fd("exit: too many arguments\n", 2);
		if (data)
			data->last_status = 1;
		return (data->last_status);
	}
	return (parse_and_set_code(argv[1], data));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtins.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/29 11:50:38 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/29 11:50:47 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

static struct s_builtin_entry
{
	const char		*name;
	int				(*fn)(char **argv, t_data *data);
	int				run_in_parent;
} g_builtins[] = {
	{"echo", builtin_echo, 0},
	{"pwd", builtin_pwd, 0},
	{"cd", builtin_cd, 1},
	{"exit", builtin_exit, 1},
	{"export", builtin_export, 1},
	{"unset", builtin_unset, 1},
	{NULL, NULL, 0}
};

int	is_builtin(const char *name)
{
	int	i;

	if (!name)
		return (0);
	i = 0;
	while (g_builtins[i].name)
	{
		if (ft_strncmp(g_builtins[i].name, name,
				(ft_strlen(g_builtins[i].name) + 1)) == 0)
			return (1);
		i++;
	}
	return (0);
}

int	builtin_should_run_in_parent(const char *name)
{
	int	i;

	if (!name)
		return (0);
	i = 0;
	while (g_builtins[i].name)
	{
		if (ft_strncmp(g_builtins[i].name, name,
				ft_strlen(g_builtins[i].name) + 1) == 0)
			return (g_builtins[i].run_in_parent);
		i++;
	}
	return (0);
}

int	call_builtin(char **argv, t_data *data)
{
	int	i;

	if (!argv || !argv[0])
		return (1);
	i = 0;
	while (g_builtins[i].name)
	{
		if (ft_strncmp(g_builtins[i].name, argv[0],
				(ft_strlen(g_builtins[i].name) + 1)) == 0)
			return (g_builtins[i].fn(argv, data));
		i++;
	}
	return (127);
}

void	builtin_error(const char *cmd, const char *arg, const char *message)
{
	write(2, "minishell: ", 11);
	write(2, cmd, ft_strlen(cmd));
	write(2, ": `", 3);
	write(2, arg, ft_strlen(arg));
	write(2, "': ", 3);
	write(2, message, ft_strlen(message));
	write(2, "\n", 1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   helper_cd.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelona.co  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/04 15:15:14 by jadelgad          #+#    #+#             */
/*   Updated: 2026/02/04 15:15:17 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

static char	*raw_no_arg(void)
{
	char	*raw;

	raw = ft_strdup("");
	if (!raw)
		return (NULL);
	return (raw);
}

static char	*raw_double_dash(char **argv)
{
	char	*raw;

	if (argv[2])
		raw = ft_strdup(argv[2]);
	else
		raw = ft_strdup("");
	if (!raw)
		return (NULL);
	return (raw);
}

static char	*raw_dash_oldpwd(t_data *data)
{
	const char	*oldpwd;
	char		*raw;

	oldpwd = get_var_from_envp(data->envp, "OLDPWD");
	if (!oldpwd)
	{
		ft_putstr_fd("cd: OLDPWD not set\n", 2);
		return (NULL);
	}
	raw = ft_strdup(oldpwd);
	if (!raw)
		return (NULL);
	return (raw);
}

static char	*raw_from_arg(char **argv)
{
	char	*raw;

	raw = ft_strdup(argv[1]);
	if (!raw)
		return (NULL);
	return (raw);
}

char	*get_raw_cd_target(char **argv, t_data *data)
{
	char	*raw;

	if (!argv || !data)
		return (NULL);
	if (!argv[1])
		return (raw_no_arg());
	if (ft_strncmp(argv[1], "--", 3) == 0)
		return (raw_double_dash(argv));
	if (ft_strncmp(argv[1], "-", 2) == 0)
		return (raw_dash_oldpwd(data));
	raw = raw_from_arg(argv);
	return (raw);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   export.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelona.co  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/04 15:14:55 by jadelgad          #+#    #+#             */
/*   Updated: 2026/02/04 15:14:58 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

int	is_valid_identifier(char *arg)
{
	int	i;

	if (!arg || arg[0] == '\0')
		return (0);
	if (!ft_isalpha(arg[0]) && arg[0] != '_')
		return (0);
	i = 1;
	while (arg[i])
	{
		if (!ft_isalnum(arg[i]) && arg[i] != '_')
			return (0);
		i++;
	}
	return (1);
}

/* ** 1. Sort helper (Bubble sort on a copy)
*/
static char	**get_sorted_env(char **envp)
{
	char	**tmp;
	int		i;
	int		j;

	tmp = dup_env(envp);
	if (!tmp)
		return (NULL);
	i = 0;
	while (tmp[i])
	{
		j = i + 1;
		while (tmp[j])
		{
			if (ft_strcmp(tmp[i], tmp[j]) > 0)
				ft_swap_str(&tmp[i], &tmp[j]);
			j++;
		}
		i++;
	}
	return (tmp);
}

/* ** 2. Print logic without extra mallocs
** Using printf precision (%.*s) prevents creating a substring just to print it
*/
static void	print_export_line(char *env_str)
{
	char	*eq;
	int		len;

	eq = ft_strchr(env_str, '=');
	if (eq)
	{
		len = (int)(eq - env_str);
		printf("declare -x %.*s=\"%s\"\n", len, env_str, eq + 1);
	}
	else
		printf("declare -x %s\n", env_str);
}

/* ** 3. Process individual argument
*/
static int	process_export_arg(t_data *data, char *arg)
{
	char	*eq;
	char	*name;
	char	*val;

	eq = ft_strchr(arg, '=');
	if (eq)
	{
		name = ft_substr(arg, 0, eq - arg);
		val = ft_strdup(eq + 1);
	}
	else
	{
		name = ft_strdup(arg);
		val = NULL;
	}
	if (!is_valid_identifier(name))
	{
		builtin_error("export", arg, "not a valid identifier");
		return (free(name), free(val), 1);
	}
	if (val != NULL)
		set_env_var_data(data, name, val);
	else if (find_name(data->envp, name) < 0)
		set_env_var_data(data, name, "");
	return (free(name), free(val), 0);
}

/* ** 4. Main Export Builtin
*/
int	builtin_export(char **argv, t_data *data)
{
	int		i;
	int		status;
	char	**sorted;

	status = 0;
	if (!argv || !argv[1])
	{
		sorted = get_sorted_env(data->envp);
		if (!sorted)
			return (1);
		i = 0;
		while (sorted[i])
			print_export_line(sorted[i++]);
		free_env(sorted);
		return (0);
	}
	i = 1;
	while (argv[i])
	{
		if (process_export_arg(data, argv[i]) != 0)
			status = 1;
		i++;
	}
	return (status);
}

/*
// hace el set de *name y *value pero no los retorna
void	split_name_value(const char *arg, char **name, char **value)
{
	char	*equal;

	if (!arg || !name || !value)
		return ;
	equal = ft_strchr(arg, '=');
	if (!equal)
	{
		*name = ft_strdup(arg);
		if (!*name)
		{
			*value = NULL;
			return ;
		}
		*value = NULL;
		return ;
	}
	*name = ft_substr(arg, 0, equal - arg);
	if (!*name)
	{
		*value = NULL;
		return ;
	}
	*value = ft_strdup(equal + 1);
	if (!*value)
	{
		free(*name);
		*name = NULL;
		return ;
	}
}

void	print_sorted_env(char **envp)
{
	char	**tmp;
	char	*name;
	char	*value;
	int		count;
	int		i;
	int		j;

	count = 0;
	while (envp[count])
		count++;
	tmp = dup_env(envp);
	i = 0;
	while (i < count)
	{
		j = i + 1;
		while (j < count)
		{
			if (ft_strcmp(tmp[i], tmp[j]) > 0)
			{
				ft_swap_str(&tmp[i], &tmp[j]);
			}
			j++;
		}
		i++;
	}
	i = 0;
	while (i < count)
	{
		name = NULL;
		value = NULL;
		split_name_value(tmp[i], &name, &value);
		if (!name)
		{
			i++;
			continue ;
		}
		if (!value)
			printf("declare -x %s\n", name);
		else
			printf("declare -x %s=\"%s\"\n", name, value);
		free(name);
		free(value);
		i++;
	}
	free_env(tmp);
}

int	builtin_export(char **argv, t_data *data)
{
	int		i;
	int		status;
	char	*name;
	char	*value;

	name = NULL;
	value = NULL;
	status = 0;
	if (argv[1] == NULL)
	{
		print_sorted_env(data->envp);
		data->last_status = 0;
		return (0);
	}
	i = 1;
	while (argv[i])
	{
		split_name_value(argv[i], &name, &value);
		if (!name)
		{
			status = 1;
			data->last_status = 1;
			i++;
			continue ;
		}
		if (!is_valid_identifier(name))
		{
			builtin_error("export", argv[i], "not a valid identifier");
			status = 1;
		}
		else
		{
			if (value == NULL)
				set_env_var_data(data, name, "");
			else
				set_env_var_data(data, name, value);
		}
		free(name);
		free(value);
		i++;
	}
	data->last_status = status;
	return (status);
}
*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtin_cd.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelona.co  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/04 15:14:13 by jadelgad          #+#    #+#             */
/*   Updated: 2026/02/04 15:14:17 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

static int	change_dir_update(const char *path, t_data *data)
{
	char	*prev;
	char	*now;

	if (!path || !data)
		return (1);
	prev = getcwd(NULL, 0);
	if (chdir(path) == -1)
	{
		perror("cd");
		free(prev);
		return (1);
	}
	now = getcwd(NULL, 0);
	if (!now)
	{
		perror("cd: getcwd");
		free(prev);
		return (1);
	}
	if (prev)
		set_env_var_generic(&data->envp, "OLDPWD", prev);
	set_env_var_generic(&data->envp, "PWD", now);
	free(prev);
	free(now);
	return (0);
}

int	builtin_cd(char **argv, t_data *data)
{
	char		*target;
	int			rc;
	const char	*pwd;

	if (!data)
		return (1);
	target = resolve_cd_target(argv, data);
	if (!target)
		return (1);
	rc = change_dir_update(target, data);
	if (rc == 0 && argv[1] && ft_strncmp(argv[1], "-", 2) == 0)
	{
		pwd = get_var_from_envp(data->envp, "PWD");
		if (pwd)
			ft_putendl_fd((char *)pwd, 1);
	}
	free(target);
	return (rc);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   assignments.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelona.co  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/04 15:16:41 by jadelgad          #+#    #+#             */
/*   Updated: 2026/02/04 15:16:44 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

void	apply_assignment(char ***penv, const char *assignment)
{
	char	*equal;
	char	*name;
	char	*value;

	equal = ft_strchr(assignment, '=');
	if (!equal)
		return ;
	name = ft_substr(assignment, 0, (equal - assignment));
	value = ft_strdup(equal + 1);
	if (!name || !value)
	{
		free(name);
		free(value);
		return ;
	}
	set_env_var_generic(penv, name, value);
	free(name);
	free(value);
}

void	apply_assignments_array(char ***penv, char **assignments)
{
	int	i;

	if (!assignments || !penv)
		return ;
	i = 0;
	while (assignments[i])
	{
		apply_assignment(penv, assignments[i]);
		i++;
	}
}

// helper to look for NAME=VALUE
int	is_assignment_word(const char *s)
{
	int	i;

	if (!s || !(ft_isalpha((unsigned char)s[0]) || s[0] == '_'))
		return (0);
	i = 1;
	while (s[i] && s[i] != '='
		&& (ft_isalnum((unsigned char)s[i]) || s[i] == '_'))
		i++;
	if (s[i] != '=')
		return (0);
	return (1);
}

int	find_name(char **envp, const char *name)
{
	int	i;
	int	len;

	len = ft_strlen(name);
	i = 0;
	while (envp[i])
	{
		if (!ft_strncmp(envp[i], name, len) && envp[i][len] == '=')
			return (i);
		i++;
	}
	return (-1);
}

char	*join_name_value(const char *name, const char *value)
{
	char	*tmp;
	char	*res;

	if (!name || !value)
		return (NULL);
	tmp = ft_strjoin(name, "=");
	if (!tmp)
		return (NULL);
	res = ft_strjoin(tmp, value);
	free(tmp);
	if (!res)
		return (NULL);
	return (res);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_utils_helper.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelona.co  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/04 15:16:57 by jadelgad          #+#    #+#             */
/*   Updated: 2026/02/04 15:17:00 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

const char	*get_var_from_envp(char **envp, const char *name)
{
	int	i;
	int	len;

	i = 0;
	len = ft_strlen(name);
	while (envp[i])
	{
		if (!ft_strncmp(envp[i], name, len) && envp[i][len] == '=')
			return (envp[i] + len + 1);
		i++;
	}
	return (NULL);
}

void	free_env(char **envp)
{
	int	i;

	i = 0;
	if (!envp)
		return ;
	while (envp[i])
	{
		free(envp[i]);
		i++;
	}
	free(envp);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_utils.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelona.co  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2026/02/04 15:16:57 by jadelgad          #+#    #+#             */
/*   Updated: 2026/02/04 15:17:00 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

char	**dup_env(char **envp)
{
	int		count;
	char	**copy;
	int		i;

	count = 0;
	while (envp[count])
		count++;
	copy = safe_malloc((count + 1) * sizeof(char *));
	i = 0;
	while (i < count)
	{
		copy[i] = ft_strdup(envp[i]);
		i++;
	}
	copy[count] = NULL;
	return (copy);
}

static int	append_env(char ***penv, char *new_entry)
{
	int		count;
	int		i;
	char	**new_env;

	count = 0;
	while ((*penv)[count])
		count++;
	new_env = safe_malloc((count + 2) * sizeof(char *));
	if (!new_env)
		return (1);
	i = 0;
	while (i < count)
	{
		new_env[i] = (*penv)[i];
		i++;
	}
	new_env[count] = new_entry;
	new_env[count + 1] = NULL;
	free(*penv);
	*penv = new_env;
	return (0);
}

int	set_env_var_generic(char ***penv, const char *name, const char *value)
{
	int		i;
	char	*new_entry;

	if (!penv || !name || !value)
		return (1);
	new_entry = join_name_value(name, value);
	if (!new_entry)
		return (1);
	i = find_name(*penv, name);
	if (i >= 0)
	{
		free((*penv)[i]);
		(*penv)[i] = new_entry;
		return (0);
	}
	if (append_env(penv, new_entry))
	{
		free(new_entry);
		return (1);
	}
	return (0);
}

// wrapper fo r persistent cases
int	set_env_var_data(t_data *data, const char *name, const char *value)
{
	return (set_env_var_generic(&data->envp, name, value));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_atoi.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/08 12:20:37 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 08:08:53 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_atoi(const char *nptr)
{
	long	result;
	int		sign;
	int		i;

	i = 0;
	while (nptr[i] == ' ' || (nptr[i] >= 9 && nptr[i] <= 13))
		i++;
	sign = 1;
	if (nptr[i] == '-' || nptr[i] == '+')
	{
		if (nptr[i] == '-')
			sign = -1;
		i++;
	}
	result = 0;
	while (nptr[i] >= '0' && nptr[i] <= '9')
	{
		result = result * 10 + (nptr[i] - '0');
		i++;
	}
	return ((int)(result * sign));
}
/*
#include <stdio.h>

int	main()
{
	char *str = "  -42BCN";

	printf("%d\n", ft_atoi(str));
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlcpy.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/08 08:38:25 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/15 12:58:20 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"
#include <stddef.h>

size_t	ft_strlcpy(char *dst, const char *src, size_t n)
{
	size_t	i;
	size_t	j;

	i = 0;
	j = 0;
	while (src[i] != '\0')
		i++;
	if (n > 0)
	{
		while (j < n - 1 && src[j] != '\0')
		{
			dst[j] = src[j];
			j++;
		}
		dst[j] = '\0';
	}
	return (i);
}
/*
#include <stdio.h>

int	main()
{
	char	phrase1[] = "42BCN";
	char	phrase2[] = "to the moon";
	int		result;

	result = ft_strlcpy(phrase1, phrase2, 6);
	printf("%d\n", result);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strncmp.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/07 14:44:09 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/18 13:00:18 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_strncmp(const char *s1, const char *s2, size_t n)
{
	size_t	i;

	if (n == 0)
		return (0);
	i = 0;
	while (i < n -1 && s1[i] != '\0' && s2[i] != '\0')
	{
		if (s1[i] != s2[i])
			return ((unsigned char)s1[i] - (unsigned char)s2[i]);
		i++;
	}
	return ((unsigned char)s1[i] - (unsigned char) s2[i]);
}
/*
#include <stdio.h>

int	main()
{
	char *str1 = "42 to the Moon";
	char *str2 = "42 to the Sun";

	printf("%d\n", ft_strncmp(str1,str2, 50));
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memcmp.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/08 10:39:28 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/16 09:18:10 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_memcmp(const void *s1, const void *s2, size_t n)
{
	size_t			i;
	unsigned char	*str1;
	unsigned char	*str2;

	i = 0;
	str1 = (unsigned char *)s1;
	str2 = (unsigned char *)s2;
	while (i < n)
	{
		if (str1[i] != str2[i])
			return (str1[i] - str2[i]);
		i++;
	}
	return (0);
}
/*
#include <stdio.h>

int	main()
{
	char *str1 = "42 To the Moon";
	char *str2 = "42 to the Moon";

	printf("%d\n", ft_memcmp(str1, str2, 50));
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strdup.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/08 14:06:09 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/16 11:37:34 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_strdup(const char *s)
{
	char	*dst;
	size_t	len;

	len = ft_strlen(s);
	dst = ft_calloc(len + 1, sizeof(char));
	if (!dst)
		return (NULL);
	ft_strlcpy(dst, s, len + 1);
	return (dst);
}
/*
#include <stdio.h>

int	main()
{
	char	*str1 = "42BCn to the Moon!";

	printf("%s", ft_strdup(str1));
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isascii.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/05 15:15:43 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/15 10:39:29 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_isascii(int c)
{
	if (c >= 0 && c <= 127)
		return (1);
	else
		return (0);
}
/*
#include <stdio.h>

int	main()
{
	char	alpha;
	char	digit;
	char	alnum;
	char	print;

	alpha = 'a';
	digit = '1';
	alnum = 'a';
	print = '\n';
	printf("%d \n",ft_isscii(alpha));
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isalnum.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/05 15:04:28 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/15 10:38:26 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_isalnum(int c)
{
	if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))
		return (1);
	else if ((c >= '0') && (c <= '9'))
		return (1);
	else
		return (0);
}
/*
#include <stdio.h>

int	main()
{
	char	alpha;
	char	digit;
	char	alnum;
	char	print;

	alpha = 'a';
	digit = '1';
	alnum = 'a';
	print = '\n';
	printf("%d \n",ft_isalnum(alnum));
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memmove.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/07 11:19:58 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/18 13:05:04 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"
#include <stddef.h>

static void	ft_cpyforward(
	unsigned char *dst, const unsigned char *src, size_t n)
{
	size_t	i;

	i = 0;
	while (i < n)
	{
		dst[i] = src[i];
		i++;
	}
}

static void	ft_cpybackward(unsigned char *dst, const void *src, size_t n)
{
	const unsigned char	*s;

	s = (const unsigned char *)src;
	while (n-- > 0)
		dst[n] = s[n];
}

void	*ft_memmove(void *dest, const void *src, size_t n)
{
	unsigned char	*ptr_src;
	unsigned char	*ptr_dest;

	ptr_src = (unsigned char *)src;
	ptr_dest = (unsigned char *)dest;
	if (n == 0 || dest == src)
		return (dest);
	if (ptr_dest < ptr_src)
		ft_cpyforward(ptr_dest, ptr_src, n);
	else
		ft_cpybackward(ptr_dest, ptr_src, n);
	return (dest);
}
/*
#include <stdio.h>

int	main()
{
	char	dst[30];
	char	src[] = "42BCN to the Moon my Frate!";
	ft_memmove(dst, src, 10);
	printf("%s\n", dst);
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_bzero.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/07 08:24:01 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/15 11:25:12 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_bzero(void *s, size_t n)
{
	size_t			i;
	unsigned char	*ptr;

	i = 0;
	ptr = (unsigned char *)s;
	if (n == 0)
		return ;
	while (i < n)
	{
		ptr[i] = '\0';
		i++;
	}
}
/*
#include <stdio.h>

int	main()
{
	char	phrase[] = "42BCN to the moon";
	size_t len = 5;
	
	ft_bzero(phrase, len);
	printf("%c\n", phrase[3]);
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memset.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/05 15:58:50 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/15 11:11:35 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	*ft_memset(void *s, int c, size_t n)
{
	size_t			i;
	unsigned char	*ptr;

	ptr = (unsigned char *)s;
	i = 0;
	if (n == 0)
		return (s);
	while (i < n)
	{
		ptr[i] = (unsigned char) c;
		i++;
	}
	return (s);
}
/*
#include <stdio.h>

int	main()
{
	char phrase[] = "42BCN";
	char c;

	c = 'X';
	ft_memset(phrase, c, 2);
	printf("%s \n", phrase);
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_toupper.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/08 08:18:19 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/18 13:00:54 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"
#include <stdio.h>

int	ft_toupper(int c)
{
	if (c >= 97 && c <= 122)
		return (c - 32);
	return (c);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memchr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/07 15:32:30 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/16 09:17:21 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	*ft_memchr(const void *s, int c, size_t n)
{
	size_t				i;
	const unsigned char	*ptr;

	i = 0;
	ptr = (const unsigned char *)s;
	while (i < n)
	{
		if (ptr[i] == (unsigned char)c)
			return ((void *)&ptr[i]);
		i++;
	}
	return (NULL);
}
/*
#include <stdio.h>

int	main()
{
	char	*str1 = "42 to the Moon!";
	char	letr = 'h';

	printf("%s\n", (char *)ft_memchr(str1, letr, 20));
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_substr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/09 16:33:27 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 08:14:27 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_substr(char const *s, unsigned int start, size_t len)
{
	size_t	s_len;
	size_t	i;
	char	*sub;

	i = 0;
	if (!s)
		return (NULL);
	s_len = ft_strlen(s);
	if (start >= s_len)
		return (ft_calloc(1, sizeof(char)));
	if (len > s_len - start)
		len = s_len - start;
	sub = ft_calloc(len + 1, sizeof(char));
	if (!sub)
		return (NULL);
	while (i < len)
	{
		sub[i] = s[i + start];
		i++;
	}
	return (sub);
}
/*
#include <stdio.h>

int	main()
{
	char	*str1 = "42BCN to the Moon!";

	printf("%s\n", ft_substr(str1, 6, 15));
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strchr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/07 12:59:51 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/13 12:52:51 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_strchr(const char *s, int c)
{
	int	i;

	i = 0;
	while (1)
	{
		if (s[i] == (char)c)
			return ((char *)(s + i));
		if (s[i] == '\0')
			break ;
		i++;
	}
	return (NULL);
}
/*
#include <stdio.h>
int	main()
{
	char	frase[30] = "ABCDEFGHIJK";
	int	letra = 'F';
	printf("%s\n",ft_strchr(frase, letra));
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putstr_fd.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/13 10:02:36 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 10:54:17 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

void	ft_putstr_fd(char *s, int fd)
{
	int	i;

	i = 0;
	if (!s)
		return ;
	while (s[i] != '\0')
	{
		write(fd, &s[i], 1);
		i++;
	}
}
/*
int	main()
{
	char	str1;

	str1[] = "42 to the Moon!";
	ft_putstr_fd(str1, 1);
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isdigit.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/05 14:12:00 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/15 10:37:02 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_isdigit(int c)
{
	if (c >= 48 && c <= 57)
		return (1);
	else
		return (0);
}
/*
#include <stdio.h>

int	main()
{
	char	alpha;
	char	digit;
	char	alnum;
	char	print;

	alpha = 'a';
	digit = '1';
	alnum = 'a';
	print = '\n';
	printf("%d \n",ft_isdigit(digit));
	return (0);
}
*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlen.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/05 12:02:56 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/15 10:58:14 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

size_t	ft_strlen(const char *s)
{
	int	i;

	i = 0;
	while (s[i] != '\0')
		i++;
	return (i);
}
/*
#include <stdio.h>

int	main()
{
	char	*alpha;

	alpha = "42BCN";
	printf("%ld \n",ft_strlen(alpha));
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putnbr_fd.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/13 10:04:06 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 11:10:02 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_putnbr_fd(int n, int fd)
{
	long	num;

	if (fd < 0)
		return ;
	num = n;
	if (num < 0)
	{
		ft_putchar_fd('-', fd);
		num = -num;
	}
	if (num >= 10)
		ft_putnbr_fd(num / 10, fd);
	ft_putchar_fd(num % 10 + '0', fd);
}
/*
int	main()
{
	int	number;

	number = 42;
	ft_putnbr_fd(number, 1);
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putendl_fd.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/13 10:03:29 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 11:05:40 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"
#include <unistd.h>

void	ft_putendl_fd(char *s, int fd)
{
	if (!s || fd <= 0)
		return ;
	ft_putstr_fd(s, fd);
	ft_putchar_fd('\n', fd);
}
/*
int	main()
{
	char	str1[] = "42 to teh Moon!";

	ft_putendl_fd(str1, 1);
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_striteri.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/13 10:01:01 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/19 08:19:24 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_striteri(char *s, void (*f)(unsigned int, char *))
{
	unsigned int	i;

	if (!s || !f)
		return ;
	i = 0;
	while (s[i])
	{
		f(i, &s[i]);
		i++;
	}
}
/*
#include <stdio.h>

void	funsion(unsigned int i, char *str)
{
	if (i % 2 == 0)
		*str = ft_toupper(*str);
	else
		*str = ft_tolower(*str);
}

int	main()
{
	char	str[] = "42 To the moon!";

	ft_striteri(str, funsion);
	printf("%s\n", str);
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isalpha.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/05 12:41:50 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/15 10:31:37 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_isalpha(int c)
{
	if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))
		return (1);
	else
		return (0);
}
/*
#include <stdio.h>

int	main()
{
	char	alpha;
	char	digit;
	char	alnum;
	char	print;

	alpha = 'a';
	digit = '1';
	alnum = 'a';
	print = '\n';
	printf("%d \n",ft_isalpha(alpha));
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strtrim.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/10 13:44:56 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 08:18:01 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_find_set(char c, const char *set)
{
	while (*set)
	{
		if (c == *set)
			return (1);
		set++;
	}
	return (0);
}

char	*ft_strtrim(char const *s1, char const *set)
{
	size_t	start;
	size_t	end;
	size_t	len;
	char	*result;

	if (!s1 || !set)
		return (NULL);
	start = 0;
	end = ft_strlen(s1);
	while (s1[start] != '\0' && ft_find_set(s1[start], set))
		start++;
	while (end > start && ft_find_set(s1[end - 1], set))
		end--;
	len = end - start;
	result = ft_calloc(len + 1, sizeof(char));
	if (!result)
		return (NULL);
	ft_strlcpy(result, s1 + start, len + 1);
	return (result);
}
/*
#include <stdio.h>

int	main()
{
	char	*str = "42BCN42";
	char	c	=	'4';

	
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_tolower.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/08 08:16:23 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/15 13:55:02 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_tolower(int c)
{
	if (c >= 65 && c <= 90)
		return (c + 32);
	return (c);
}
/*
#include <stdio.h>

int	main()
{
	char	letter;
	char	result;

	letter = 'A';
	result = ft_tolower(letter);
	printf("%c\n", result);
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strrchr.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/07 14:24:41 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 08:11:39 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_strrchr(const char *s, int c)
{
	int	i;

	i = 0;
	while (s[i])
		i++;
	while (i >= 0)
	{
		if (s[i] == (char)c)
			return ((char *)(s + i));
		i--;
	}
	return (NULL);
}
/*
#include <stdio.h>
int	main()
{
	char	frase[30] = "ABCDEFGHIJFK";
	int	letra = 'F';
	printf("%s\n",ft_strrchr(frase, letra));
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memcpy.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/07 10:18:33 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 07:55:34 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	*ft_memcpy(void *dest, const void *src, size_t n)
{
	size_t			i;
	unsigned char	*ptr_src;
	unsigned char	*ptr_dest;

	i = 0;
	ptr_src = (unsigned char *)src;
	ptr_dest = (unsigned char *)dest;
	if (!dest && !src)
		return (NULL);
	while (i < n)
	{
		ptr_dest[i] = ptr_src[i];
		i++;
	}
	return (dest);
}
/*
#include <stdio.h>

int	main()
{
	char	phrase[] = "42BCN to the Moon my Frate";
	char	dest[50];
	size_t	n;

	n = 5;
	ft_memcpy(dest, phrase, n);
	printf("%s\n", dest);
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_itoa.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/13 09:58:47 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/19 08:18:40 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

static int	ft_get_len(int n)
{
	int	len;

	len = 0;
	if (n <= 0)
		len = 1;
	while (n != 0)
	{
		len++;
		n /= 10;
	}
	return (len);
}

static void	ft_fill_str(char *str, int n, int len)
{
	if (n == 0)
		str[0] = '0';
	if (n < 0)
	{
		str[0] = '-';
		n = n * -1;
	}
	str[len] = '\0';
	while (n)
	{
		str[--len] = (n % 10) + '0';
		n = n / 10;
	}
}

char	*ft_itoa(int n)
{
	char	*str;
	int		len;

	if (n == -2147483648)
		return (ft_strdup("-2147483648"));
	len = ft_get_len(n);
	str = malloc(len + 1);
	if (!str)
		return (NULL);
	ft_fill_str(str, n, len);
	return (str);
}
/*
#include <stdio.h>

int	main()
{
	int	n = 42;

	printf("%s",ft_itoa(n));
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isprint.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/05 15:18:16 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/15 10:40:42 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_isprint(int c)
{
	if (c >= 32 && c <= 126)
		return (1);
	else
		return (0);
}
/*
#include <stdio.h>

int	main()
{
	char	alpha;
	char	digit;
	char	alnum;
	char	print;

	alpha = 'a';
	digit = '1';
	alnum = 'a';
	print = '\n';
	printf("%d \n",ft_isprint(print));
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_calloc.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/08 13:31:48 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/16 11:23:57 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	*ft_calloc(size_t nmemb, size_t size)
{
	void	*ptr;

	ptr = malloc(nmemb * size);
	if (!ptr)
		return (NULL);
	ft_bzero(ptr, nmemb * size);
	return (ptr);
}
/*
#include <stdio.h>

int	main()
{
	char	*str;

	str = (char *)ft_calloc(2, 4);
	str[0] = 'a';
	str[3] = 'b';
	printf("%s", str);
	return (0);	
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putchar_fd.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/13 10:02:01 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 11:08:52 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_putchar_fd(char c, int fd)
{
	if (fd < 0)
		return ;
	write(fd, &c, 1);
}
/*
int	main()
{
	char	letter;

	letter = 'A';
	ft_putchar_fd(letter, 1)
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strmapi.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/13 09:59:38 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/18 15:58:43 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_strmapi(char const *s, char (*f) (unsigned int, char))
{
	char	*str;
	size_t	len;
	size_t	i;

	if (!s || !f)
		return (NULL);
	len = ft_strlen(s);
	str = malloc (len + 1);
	if (!str)
		return (NULL);
	i = 0;
	while (s[i])
	{
		str[i] = f(i, s[i]);
		i++;
	}
	str[i] = '\0';
	return (str);
}
/*
#include <stdio.h>
 char    funsion(unsigned int valor, char letra)
 {
	if (valor % 2 == 0)
	letra = ft_toupper(letra);
	else
	letra = ft_tolower(letra);
	 return (letra);
}

int	main()
{
	char	str[] = "42 to the moon!";
	char	*result = ft_strmapi(str, funsion);

	printf("%s\n", result);
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_split.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/10 15:44:46 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 10:13:14 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

static int	ft_numofwrds(char const *s, char c)
{
	int	words_num;
	int	in_word;

	words_num = 0;
	in_word = 0;
	while (*s)
	{
		if (*s != c && !in_word)
		{
			in_word = 1;
			words_num++;
		}
		else if (*s == c)
			in_word = 0;
		s++;
	}
	return (words_num);
}

static char	*ft_cpywrd(const char *start, size_t len)
{
	char	*word;

	word = (char *)malloc(len + 1);
	if (!word)
		return (NULL);
	ft_strlcpy(word, start, len + 1);
	return (word);
}

static void	ft_free_mem(char **list, size_t until)
{
	size_t	i;

	i = 0;
	while (i < until)
	{
		free(list[i]);
		i++;
	}
	if (list)
		free (list);
}

static int	ft_extract_word(char const **s, char c, char **list, size_t *i)
{
	const char	*start;

	while (**s == c)
		(*s)++;
	start = *s;
	while (**s != c && **s != '\0')
		(*s)++;
	if (*s > start)
	{
		list[*i] = ft_cpywrd(start, *s - start);
		if (!list[*i])
			return (-1);
		(*i)++;
		return (1);
	}
	return (0);
}

char	**ft_split(char const *s, char c)
{
	char		**list;
	int			result;
	size_t		i;
	size_t		word_count;

	if (!s)
		return (NULL);
	word_count = ft_numofwrds(s, c);
	list = (char **)ft_calloc(word_count + 1, sizeof(char *));
	if (!list)
		return (NULL);
	i = 0;
	while (*s && i < word_count)
	{
		result = ft_extract_word(&s, c, list, &i);
		if (result == -1)
		{
			ft_free_mem(list, i);
			return (NULL);
		}
	}
	return (list);
}
/*
#include <stdio.h>

int	main()
{
    char *str = "42BCN to the Moon!";
    char **result = ft_split(str, ' ');
    size_t i = 0;

    if (!result)
        return (1);
    while (result[i])
    {
        printf("%s\n", result[i]);
        i++;
    }
    return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strjoin.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/09 16:36:02 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 08:17:08 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_strjoin(char const *s1, char const *s2)
{
	size_t	i;
	size_t	j;
	char	*s1s2;	

	if (!s1 || !s2)
		return (NULL);
	s1s2 = ft_calloc(ft_strlen(s1) + ft_strlen(s2) + 1, sizeof(char));
	if (!s1s2)
		return (NULL);
	i = 0;
	j = 0;
	while (s1[i])
	{
		s1s2[i] = s1[i];
		i++;
	}
	while (s2[j])
	{
		s1s2[i + j] = s2[j];
		j++;
	}
	return (s1s2);
}
/*
#include <stdio.h>

int	main()
{
	char	*str1 = "42BCN ";
	char	*str2 = "to the Moon!";

	printf("%s", ft_strjoin(str1, str2));
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strnstr.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/08 11:49:30 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/16 08:51:58 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_strnstr(const char *big, const char *little, size_t len)
{
	size_t	i;
	size_t	j;

	i = 0;
	if (*little == '\0')
		return ((char *)big);
	while (big[i] != '\0' && i < len)
	{
		j = 0;
		while (little[j] && big[i + j] == little[j] && i + j < len)
			j++;
		if (little[j] == '\0')
			return ((char *)big + i);
		i++;
	}
	return (NULL);
}
/*
#include <stdio.h>

int	main()
{
	char	*phrase1 = "42BCN to the moon";
	char	*phrase2 = "the moon";

	printf("%s\n", ft_strnstr(phrase1, phrase2, 20));
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlcat.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/08 09:17:56 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/15 13:29:12 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"
#include <stddef.h>

size_t	ft_strlcat(char *dst, const char *src, size_t size)
{
	size_t	i;
	size_t	j;

	i = 0;
	j = 0;
	while (dst[i] && i < size)
		i++;
	if (i == size)
		return (size + ft_strlen(src));
	while (src[j] && (i + j) < size - 1)
	{
		dst[i + j] = src[j];
		j++;
	}
	if (i + j < size)
		dst[i + j] = '\0';
	return (i + ft_strlen(src));
}
/*
#include <stdio.h>

int	main()
{
	size_t	result;
	char	phrase1[] = "42BCN";
	char	phrase2[] = " to the moon my frate!";
	result = ft_strlcat(phrase1, phrase2, 8);
	printf("%zu \n", result);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstsize_bonus.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/19 08:47:29 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 13:01:29 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_lstsize(t_list *lst)
{
	size_t	i;

	i = 0;
	while (lst)
	{
		i++;
		lst = lst->next;
	}
	return ((int)i);
}
/*
#include <stdio.h>

int	main()
{
	char	*str1 = ft_strdup("42 ");
	char	*str2 = ft_strdup("to the Moon!");
	t_list	*lista = NULL;
	t_list	*nodo1 = ft_lstnew(str1);
	t_list	*nodo2 = ft_lstnew(str2);
	if (!nodo1 || !nodo2)
		return (1);
	ft_lstadd_back(&lista, nodo1);
	ft_lstadd_back(&lista, nodo2);
	t_list	*temp = lista;
	while (temp)
	{	
		printf("%s\n", (char *) temp->content);
		temp = temp->next;
	}
	printf("%d\n" ,ft_lstsize(lista));
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstlast_bonus.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/19 09:23:04 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 13:10:28 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

t_list	*ft_lstlast(t_list *lst)
{
	if (!lst)
		return (NULL);
	while (lst->next)
	{
		lst = lst->next;
	}
	return (lst);
}
/*
#include <stdio.h>

int	main()
{
	char	*str1 = ft_strdup("42 ");
	char	*str2 = ft_strdup("to the Moon!");
	t_list	*lista = NULL;
	t_list	*nodo1 = ft_lstnew(str1);
	t_list	*nodo2 = ft_lstnew(str2);
	if (!nodo1 || !nodo2)
		return (1);
	ft_lstadd_back(&lista, nodo1);
	ft_lstadd_back(&lista, nodo2);
	t_list	*temp = lista;
	while (temp)
	{	
		printf("%s\n", (char *) temp->content);
		temp = temp->next;
	}
	t_list	*last = ft_lstlast(lista);
	if (last)
		printf("ultimo nodo : %s\n", (char *)ultimo->content)
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstadd_back_bonus.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/19 09:38:52 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 13:24:25 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_lstadd_back(t_list **lst, t_list *new)
{
	t_list	*last;

	if (!lst || !new)
		return ;
	if (!*lst)
	{
		*lst = new;
		return ;
	}
	last = *lst;
	while (last->next)
		last = last->next;
	last->next = new;
}
/*
#include <stdio.h>

int	main()
{
	char	*str1 = ft_strdup("42 ");
	char	*str2 = ft_strdup("to the Moon!");
	t_list	*lista = NULL;
	t_list	*nodo1 = ft_lstnew(str1);
	t_list	*nodo2 = ft_lstnew(str2);
	if (!nodo1 || !nodo2)
		return (1);
	ft_lstadd_back(&lista, nodo1);
	ft_lstadd_back(&lista, nodo2);
	t_list	*temp = lista;
	while (temp)
	{	
		printf("%s\n", (char *) temp->content);
		temp = temp->next;
	}
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstdelone_bonus.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/19 10:44:24 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 12:38:05 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_lstdelone(t_list *lst, void (*del)(void*))
{
	if (!lst || !del)
		return ;
	del(lst->content);
	free(lst);
}
/*
#include <stdio.h>

void	del(void *content)
{
	free(content);
}

int	main()
{
	char	*str1 = ft_strdup("42 ");
	char	*str2 = ft_strdup("to the Moon!");
	t_list	*lista = NULL;
	t_list	*nodo1 = ft_lstnew(str1);
	t_list	*nodo2 = ft_lstnew(str2);
	if (!nodo1 || !nodo2)
		return (1);
	ft_lstadd_back(&lista, nodo1);
	ft_lstadd_back(&lista, nodo2);
	t_list	*temp = lista;
	while (temp)
	{	
		printf("%s\n", (char *) temp->content);
		temp = temp->next;
	}
	ft_lstdelone(nodo1, del);
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstclear_bonus.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/19 11:01:05 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 12:46:50 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_lstclear(t_list **lst, void (*del)(void *))
{
	t_list	*tmp;

	if (!lst || !*lst || !del)
		return ;
	while (*lst)
	{
		tmp = (*lst)->next;
		ft_lstdelone(*lst, del);
		*lst = tmp;
	}
	*lst = NULL;
}
/*
#include <stdio.h>

#include <stdio.h>

void	del(void *content)
{
	free(content);
}

int	main()
{
	char	*str1 = ft_strdup("42 ");
	char	*str2 = ft_strdup("to the Moon!");
	t_list	*lista = NULL;
	t_list	*nodo1 = ft_lstnew(str1);
	t_list	*nodo2 = ft_lstnew(str2);
	if (!nodo1 || !nodo2)
		return (1);
	ft_lstadd_back(&lista, nodo1);
	ft_lstadd_back(&lista, nodo2);
	t_list	*temp = lista;
	while (temp)
	{	
		printf("%s\n", (char *) temp->content);
		temp = temp->next;
	}
	ft_lstclear(&lista, del);
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstadd_front_bonus.c                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/19 08:42:21 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 11:31:12 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_lstadd_front(t_list **lst, t_list *new)
{
	new -> next = *lst;
	*lst = new;
}
/*
#include <stdio.h>

int	main()
{
	char	*str1 = "42 to ";
	char	*str2 = "the Moon!";
	t_list	nodo1;
	t_list	nodo2;
	t_list	lista = NULL;

	nodo1 = ft_lstnew(str1);
	nodo2 = ft_lstnew(str2);
	if (!nodo1 || !nodo2)
		return (1);

	ft_lstadd_front(&lista, nodo2);
	ft_lstadd_front(&lista, nodo1);
	while (lista)
	{
		printf("Conrtenido de nodo: %s\n", (char *)lista->content);
		lista = lista->next;
	}
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstnew_bonus.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/18 12:57:52 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 11:20:00 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

t_list	*ft_lstnew(void *content)
{
	t_list	*node;

	node = malloc(sizeof(t_list));
	if (!node)
		return (NULL);
	node->content = content;
	node->next = NULL;
	return (node);
}
/*
#include <stdio.h>

int	main()
{
	char	*str1 = "42 to the Moon!";
	t_list	*nodo1;

	nodo1 = ft_lstnew(str1);
	if (!nodo1)
	{
		printf("Error al crear el nodo!");
		return (1);
	}

	printf("El contenido es : %s\n", (char *)nodo1->content);
	printf("El next de este nodo es: %p\n", (void *) nodo1->next);
	free(nodo1);
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstiter_bonus.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/19 11:45:37 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 13:22:46 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_lstiter(t_list *lst, void (*f)(void *))
{
	if (!lst || !f)
		return ;
	while (lst)
	{
		f(lst->content);
		lst = lst->next;
	}
}
/*
#include <stdio.h>

void	to_upper(void *content)
{
	char	*str = (char *)content;
	int	i = 0;
	while (str[i])
	{
		str[i] = ft_toupper(str[i]);
		i++;
	}
}

int	main()
{
	char	*str1 = ft_strdup("42 ");
	char	*str2 = ft_strdup("to the Moon!");
	t_list	*lista = NULL;
	t_list	*nodo1 = ft_lstnew(str1);
	t_list	*nodo2 = ft_lstnew(str2);
	if (!nodo1 || !nodo2)
		return (1);
	ft_lstadd_back(&lista, nodo1);
	ft_lstadd_back(&lista, nodo2);
	t_list	*temp = lista;
	while (temp)
	{	
		printf("%s\n", (char *) temp->content);
		temp = temp->next;
	}
	ft_lstiter(lista, to_upper;
	temp = lista;
	while (temp)
	{
		printf("%s\n", (char *)temp->content);
		temp = temp->next;
	}
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstmap_bonus.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/19 12:47:19 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 13:33:31 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

t_list	*ft_lstmap(t_list *lst, void *(*f)(void *), void (*del)(void *))
{
	t_list	*new_list;
	t_list	*new_node;
	void	*new_content;

	new_list = NULL;
	while (lst)
	{
		new_content = f(lst->content);
		if (!new_content)
		{
			ft_lstclear(&new_list, del);
			return (NULL);
		}
		new_node = ft_lstnew(new_content);
		if (!new_node)
		{
			del(new_content);
			ft_lstclear(&new_list, del);
			return (NULL);
		}
		ft_lstadd_back(&new_list, new_node);
		lst = lst->next;
	}
	return (new_list);
}
/*
#include <stdio.h>

void *to_upper_copy(void *content)
{
    char	*str = (char *)content;
    char	*copy = ft_strdup(str);

    if (!copy)
        return (NULL);
    for (int i = 0; copy[i]; i++)
        copy[i] = ft_toupper(copy[i]);
    return (copy);
}

void del(void *content)
{
    free(content);
}

int	main()
{
	char	*str1 = ft_strdup("42 ");
	char	*str2 = ft_strdup("to the Moon!");
	t_list	*lista = NULL;
	t_list	*nodo1 = ft_lstnew(str1);
	t_list	*nodo2 = ft_lstnew(str2);
	if (!nodo1 || !nodo2)
		return (1);
	ft_lstadd_back(&lista, nodo1);
	ft_lstadd_back(&lista, nodo2);
	t_list	*temp = lista;
	while (temp)
	{	
		printf("%s\n", (char *) temp->content);
		temp = temp->next;
	}
	t_list	*newlst = list;
	if (!newlist)
	{
		ft_clearlst(&lista, del);
		return (1);
	}
	temp = newlist;
	while (temp)
	{
		printf("%s\n", temp->content)
		temp = temp->next;
	}
	return (0);
}*/
