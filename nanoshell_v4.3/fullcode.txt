/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/03 14:58:53 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/29 13:20:59 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

static void	print_banner(void)
{
	printf("\n");
	printf(C);
	printf("         ██╗       ██╗       ███╗   ███╗    \n");
	printf("         ██║       ██║       ████╗ ████║    \n");
	printf("         ██║    ████████╗    ██╔████╔██║    \n");
	printf("    ██   ██║    ██╔═██╔═╝    ██║╚██╔╝██║    \n");
	printf("    ╚█████╔╝    ██████║      ██║ ╚═╝ ██║    \n");
	printf("     ╚════╝     ╚═════╝      ╚═╝     ╚═╝    \n");
	printf("                                             \n");
	printf("    ███████╗██╗  ██╗███████╗██╗     ██╗     \n");
	printf("    ██╔════╝██║  ██║██╔════╝██║     ██║     \n");
	printf("    ███████╗███████║█████╗  ██║     ██║     \n");
	printf("    ╚════██║██╔══██║██╔══╝  ██║     ██║     \n");
	printf("    ███████║██║  ██║███████╗███████╗███████╗\n");
	printf("    ╚══════╝╚═╝  ╚═╝╚══════╝╚══════╝╚══════╝\n");
	printf("                                             \n");
	printf(RST"\n");
}

int	main(int ac, char **argv, char **envp)
{
	t_data	data;
	char *line;
	(void)ac;
	(void)argv;	

	// 1. Initialize core state
	line = NULL;
	data.last_status = 0;
	data.running = 0;
	data.cmd = NULL;
	data.exit = "exit";
	data.envp = envp;
	data.pipes = NULL;
	data.pipes_count = 0;
	// 2. Setup signals for Ctrl-C, Ctrl-
	rl_catch_signals = 0;
	setup_signals();
	
	// 3. Set History
    read_history(".nanoshell_history");
    
	// 4. Print banner
    print_banner();
	// 5. Shell loop
	while (data.running == 0)
	{
		line = readline("$> ");
		// Handle signal flag if set
		if (g_signal_received == SIGINT) 
		{
    		// Handle Ctrl-C: redisplay prompt
    		g_signal_received = 0;
    		free(line);
			continue ;
		}
		else if (g_signal_received == SIGQUIT) 
		{
    		// Handle Ctrl-\: IGNORE at prompt, just reset and do nothing
    		g_signal_received = 0;
    		free(line);
    		continue ;
		}
		if (line == NULL)
		{
			break ;
		}
		if (line[0] != '\0')
		{
			add_history(line);
		}
		data.cmd = line;
		if (strcmp(data.cmd, data.exit) == 0)
		{
			data.running = 1;
			free(line);
			break ;
		}
		// tokeniser test
		t_token	*tokens = tokenizer(line, data.last_status);
		if (!tokens)
		{
			free(line);
			continue ;
		}
		//tokens_print_simple(tokens);
		
		// parser & AST
		t_ast *tree = parser(&tokens);
		if (tree)
		{
			//ast_print(tree, 0);
			data.last_status = exec_ast(tree, &data);
			ast_free(tree);
		} 
		free_tokens(tokens);
        free(line); 
	}
	write_history(".nanoshell_history"); // Save session history
	return (0);
}


#include "nanoshell.h"

void	set_parser_error(t_parser_context *ctx, const char *message, t_token *token)
{
	if (ctx->error_status)
		return ;
	ctx->error_status = 1;
    ctx->error_message = message;
    ctx->error_token = token;
    ast_parser_error(ctx->error_message, token);
}

void	ctx_init(t_parser_context *ctx)
{
	ctx->error_status = 0;
	ctx->error_message = NULL;
	ctx->error_token = NULL;
}

t_ast   *parser(t_token **ptokens)
{
	t_parser_context	ctx;
	t_ast				*tree;

	ctx_init(&ctx);
    tree = parser_logical(ptokens,  &ctx);
	
	// check for parse errors
	if (ctx.error_status)
	{
		if (tree)
			ast_free(tree);
		return (NULL);
	}
	// check for leftover (unexpected) tokens
	if (*ptokens != NULL)
	{
		set_parser_error(&ctx, "unexpected extra input", *ptokens);
		ast_parser_error(ctx.error_message, ctx.error_token);
		if (tree)
            ast_free(tree);
        return (NULL);
	}
	return (tree);
}


#include "nanoshell.h"
/*
// Utility: error handling wrapper
void set_parser_error(t_parser_context *ctx, const char *message, t_token *token)
{
    ctx->error_status = 1;
    ctx->message = message;
    ctx->error_token = token;
    ast_parser_error(message, token);
} ✅

// Example in parser_commands:
t_ast *parser_commands(t_token **ptokens, t_parser_context *ctx)
{
    ...
    // Check for illegal token at start (e.g., redirection with no command)
    if (token && (token->type == TOKEN_REDIR_IN
        || token->type == TOKEN_REDIR_OUT
        || token->type == TOKEN_REDIR_APPEND
        || token->type == TOKEN_HEREDOC))
    {
        set_parser_error(ctx, "redirection without command", token);
        return NULL;
    }✅
    ...
    // Later, on missing filename after redirection:
    if (!token || token->type != TOKEN_WORD)
    {
        set_parser_error(ctx, "missing file name after redirection", token);
        return NULL;
    }✅
    ...
    // At end: check for garbage tokens after valid command
    if (token && token->type != TOKEN_PIPE && / no more expected tokens /)
    {
        set_parser_error(ctx, "unexpected token after command", token);
        return NULL;
    }
    ...
}

// Example in parser_pipe:
t_ast *parser_pipe(t_token **ptokens, t_parser_context *ctx)
{
    ...
    while (token && token->type == TOKEN_PIPE)
    {
        token = token->next;
        if (!token || (token->type != TOKEN_WORD && token->type != TOKEN_LPAREN))
        {
            set_parser_error(ctx, "expected command after pipe", token);
            return NULL;
        }
        ...
    }
    ...
} ✅

// Example in parser_logical:
t_ast *parser_logical(t_token **ptokens, t_parser_context *ctx)
{
    ...
    while (token && (token->type == TOKEN_AND || token->type == TOKEN_OR))
    {
        token = token->next;
        if (!token)
        {
            set_parser_error(ctx, "operator at end of input", token);
            return NULL;
        }
        ...
    }
    ...
} ✅

// At very top-level, handle end-of-input garbage
t_ast *parser(t_token **ptokens, t_parser_context *ctx)
{
    t_ast *tree = parser_logical(ptokens, ctx);
    if (ctx->error_status)
        return NULL;
    if (*ptokens != NULL)
    {
        set_parser_error(ctx, "unexpected extra input", *ptokens);
        return NULL;
    }
    return tree;
}

*/
// Check ctx->error_status after each parsing step, and early-return if an error is detected.

t_ast *parser_commands(t_token **ptokens, t_parser_context *ctx)
{
    int             argc;
    int             i;
    char            **argv;
    t_token         *token;
    t_token_type    redirect_type;
    char            *redirect_file;
    t_ast           *cmd;
	
	token = *ptokens;
	// check for redirections without prvious command
	if (token && (token->type == TOKEN_REDIR_IN
        || token->type == TOKEN_REDIR_OUT
        || token->type == TOKEN_REDIR_APPEND
        || token->type == TOKEN_HEREDOC))
	{
		set_parser_error(ctx,  "redirection without command", token);
		return (NULL);
	}
	// count words and expansions
    argc = 0;
    while (token && (token->type == TOKEN_WORD || token->type == TOKEN_EXPANSION))
    {
        argc++;
        token = token->next;
    }
	if (argc == 0) 
	{
		set_parser_error(ctx, "empty command before operator", token);
		return NULL;
	}
    // collect and malloc arguments
    argv = safe_malloc((argc + 1) * sizeof(char*));
    token = *ptokens;
    i = 0;
    while (token && (token->type == TOKEN_WORD || token->type == TOKEN_EXPANSION))
    {
        argv[i] = ft_strdup(token->text);
        i++;
        token = token->next;
    }
    argv[i] = NULL;
    cmd = ast_new_command(argv);
    
    //  if more tokens, look for rediretions 
    while (token && (token->type == TOKEN_REDIR_IN
        || token->type == TOKEN_REDIR_OUT 
        || token->type == TOKEN_REDIR_APPEND
        || token->type == TOKEN_HEREDOC))
    {
        redirect_type = token->type;
        token = token->next;
        // make sure it comes a file after the redirection if not handle
        if (!token || token->type != TOKEN_WORD)
        {
			set_parser_error(ctx, "missing file name after redirection", token);
            return (NULL);
        }
        // heredoc
        redirect_file = NULL;
        if (redirect_type == TOKEN_HEREDOC)
        {
            // token->text is the delimeter
            redirect_file = create_heredoc_tmp(token->text); //TODO 1/2
            if (!redirect_file)
            {
                // error
                set_parser_error(ctx, "heredoc creation failed", token);
                return (NULL);
            }
        }
        else
        {
            // normal redirection
            redirect_file = ft_strdup(token->text);
            if (!redirect_file)
            {
                set_parser_error(ctx, "memory allocation failed", token);
                return (NULL);
            }
        }
        cmd = ast_new_redirect(cmd, redirect_file, redirect_type);
        token = token->next;
    }
    *ptokens = token;
    return (cmd);
}

t_ast	*parser_logical(t_token **ptokens, t_parser_context *ctx)
{
	t_token			*token;
	t_token_type	logic_type;
	t_ast			*left;
	t_ast			*right;

	token = *ptokens;
	if (token && (token->type == TOKEN_AND || token->type == TOKEN_OR)) 
	{
    	set_parser_error(ctx, "operator at start of input", token);
    	return NULL;
	}
    left = parser_pipe(&token, ctx);
	if (ctx->error_status)
		return (NULL);
	while (token && (token->type == TOKEN_AND || token->type == TOKEN_OR))
    {
        logic_type = token->type;
        token = token->next;
		if (!token)
		{
			set_parser_error(ctx,  "operator at end of input", token);
			return (NULL);
		}
        right = parser_pipe(&token, ctx);
		if (ctx->error_status)
			return (NULL);
        if (logic_type == TOKEN_AND)
            left = ast_new_and(left, right);
        else if (logic_type == TOKEN_OR)
            left = ast_new_or(left, right);
    }
    *ptokens = token;
    return (left);
}


t_ast   *parser_pipe(t_token **ptokens, t_parser_context *ctx)
{
    t_token			*token;
    t_ast           *pipe_node;
	t_ast			*left;
	t_ast			*right;
    t_ast_list      *pipe_list;
	
	token = *ptokens;
	if (token && token->type == TOKEN_PIPE)
	{
		set_parser_error(ctx, "pipe at start of input", token);
		return NULL;
	}
    left = parser_command_or_subshell(&token, ctx);
	if (ctx->error_status)
        return (NULL);
    pipe_list = ast_list_new(left);
    while (token && token->type == TOKEN_PIPE)
    {
        token = token->next;
		if (!token || (token->type != TOKEN_WORD && token->type != TOKEN_LPAREN))
		{
			set_parser_error(ctx, "expected command after pipe", token);
			return (NULL);
		}
        right  = parser_command_or_subshell(&token, ctx);
		if (ctx->error_status)
			return (NULL);
        // create new list with left, add right.. create the ast_pipe with this
        pipe_list = ast_list_append(pipe_list, right);
    }
    *ptokens = token;
    pipe_node = ast_new_pipe(pipe_list);
    return (pipe_node);
}

t_ast   *parser_subshell(t_token **ptokens, t_parser_context *ctx)
{
    t_token *token;
    t_ast   *subshell;
    t_ast   *cmd;
    
    token = *ptokens;
    cmd = NULL;
    if (token && token->type == TOKEN_LPAREN)
    {
        token = token->next; // Skip the '('
        subshell = parser(&token);
		if (ctx->error_status)
            return (NULL);
        if (!token || token->type != TOKEN_RPAREN)
        {
			set_parser_error(ctx, "missing the ')'", token);
            return (NULL);
        }
        token = token->next; // Skip the ')'
        cmd = ast_new_subshell(subshell);
    }
    *ptokens = token;
    return (cmd);
}

t_ast   *parser_command_or_subshell(t_token **ptokens, t_parser_context *ctx)
{
	t_ast	*node;

	node = NULL;
    if (*ptokens && (*ptokens)->type == TOKEN_LPAREN)
		node = parser_subshell(ptokens, ctx);
    else
		node = parser_commands(ptokens, ctx);
	
	if (ctx->error_status)
		return (NULL);
	return (node);
}

/*
Memory Management
-----------------------------------------
void ast_free(t_ast *node);             ✅
Recursively frees an entire AST and its children.

void ast_list_free(t_ast_list *list); ✅
Recursively frees an AST children list.

Error Handling and Recovery
------------------------------------------
void ast_parser_error(const char *msg, t_token *tok);
Standardizes parser error messages and possibly halts parsing.

*/

#include "nanoshell.h"

// Memory management & free
// Recursively frees an AST children list.
void ast_list_free(t_ast_list *list)
{
	if (!list)
		return ;
	ast_free(list->node);
	ast_list_free(list->next);
	free(list);
}

// free ast_nodes & children
void ast_free(t_ast *node)
{
	if (!node)
		return ;
	ast_free(node->left);
	ast_free(node->right);
	ast_list_free(node->children);
	free(node->argv);
	free(node->file);
	free(node);
}

// Error Handling

int ft_strlen_const(const char *str)
{
    int i;

    i = 0;
    while(str[i])
        i++;
    return (i);
}

void ast_parser_error(const char *message, t_token *token)
{
    const char  *prefix;
    const char  *errstr;

    prefix = "Parse error: ";
    errstr = NULL;
    // Print your base error message 
    write(2, prefix, ft_strlen_const(prefix));
    if (message)
        write (2, message, ft_strlen_const(message));
    // If there's a token, print info about it
    if (token)
    {
        write (2, " at token '", 11);
        if (token->text)
            write (2, token->text, ft_strlen_const(token->text));
        write (2, "'\n", 2);
    }
    else
        write (2, " at the end of input\n", 18);
	// If errno is set, print details
    if (errno != 0)
    {
        errstr = strerror(errno);
        write (2, "System error: ", 14);
        write(2, errstr, ft_strlen_const(errstr));
        write(2, "\n", 1);
    }
}
/*
Debugging / Printing ASTs
-----------------------------------------
void ast_print(const t_ast *root, int indent);
Prints the AST structure for debugging (indentation shows depth).
(You might want optional colored output for clarity.)
*/

#include "nanoshell.h"

// Debugging / Printing ASTs & Tokens
const char *ast_to_string(const AST_TYPE type)
{
    if (type == AST_COMMAND)
        return (C"Command"RST);
    else if (type == AST_PIPE)
        return (G"Pipe"RST);
    else if (type == AST_REDIRECT)
        return (RED"Redirection"RST);
    else if (type == AST_AND)
        return (Y"And"RST);
    else if (type == AST_OR)
        return (Y"Or"RST);
    else if (type == AST_SUBSHELL)
        return (M"Subshell"RST);
    else
        return ("Unknown");
}

void ast_print(const t_ast *root, int indent)
{
	int         i;
    int         j;
    int         k;
	t_ast_list  *current; 

	if (!root)
		return ;
	// print indetation space
	i = 0;
	while (i < indent)
	{
		printf(" ");
		i++;
	}
	// print node info
    printf("AST TYPE --> %s\n", ast_to_string(root->type));
	if (root->type == AST_COMMAND && root->argv)
    {
        j = 0;
        while (root->argv[j])
        {
            k = 0;
            while ( k < indent + 2)
            {
                printf(" ");
                k++;
            }
            printf("argv[%d]: %s\n", j, root->argv[j]);
            j++;
        }
    }
    // Print left/right children deopending on type
    ast_print(root->left, indent + 2);
    ast_print(root->right, indent + 2);
	// Print list of children depending on type
    current = root->children;
    while(current)
    {
        ast_print(current->node, indent + 2);
        current =  current->next;
    }
}
/*
// Main AST node for shell commands, pipes, redirects, logic, subshells
typedef struct s_ast {
    AST_TYPE type;          // What type of AST node this is

    // For binary nodes (AND, OR, REDIRECT, SUBSHELL, sometimes PIPE)
    struct s_ast *left;    // Left child:
                           //  - AST_AND / AST_OR: left side of logical op
                           //  - AST_REDIRECT: the command to redirect
                           //  - AST_PIPE (if binary): the first command
                           //  - AST_SUBSHELL: subtree inside the subshell
                           //  - NULL for AST_COMMAND, N-ary PIPE

    struct s_ast *right;   // Right child:
                           //  - AST_AND / AST_OR: right side of logical op
                           //  - AST_PIPE (if binary): the second command
                           //  - (Rarely used for redirect)
                           //  - NULL for AST_COMMAND, SUBSHELL, N-ary PIPE

    char **argv;           // Arguments for command:
                           //  - AST_COMMAND: array of command and its arguments
                           //  - NULL for other node types

    char *file;            // Filename for redirect:
                           //  - AST_REDIRECT: target file name for redirect (e.g., output.txt)
                           //  - NULL for other node types

    int redirect_type;     // Kind of redirect:
                           //  - AST_REDIRECT: (e.g., input, output, append)
                           //  - 0 or unused for other types

    t_ast_list *children;  // N-ary children:
                           //  - AST_PIPE: linked list of command nodes when more than two
                           //  - NULL for AST_COMMAND, REDIRECT, AND, OR, SUBSHELL
} t_ast;

*/

#include "nanoshell.h"

// Command node constructor
t_ast *ast_new_command(char **tokens)
{
	t_ast	*node;

	node = safe_malloc(sizeof(t_ast));
	node->type = AST_COMMAND;
	node->left = NULL;
	node->right = NULL;
	node->argv = tokens;
	node->file = NULL;
	node->redirect_type = 0;
	node->children = NULL;
	return (node);
}

// Pipe node constructor
t_ast *ast_new_pipe(t_ast_list *children)
{
	t_ast	*node;

	node = safe_malloc(sizeof(t_ast));
	node->type = AST_PIPE;
	node->left = NULL;
    node->right = NULL;
    node->argv = NULL;
    node->file = NULL;
    node->redirect_type = 0;
    node->children = children;
	return (node);
}

// Redirect node constructor
t_ast *ast_new_redirect(t_ast *cmd, char *file, int redirect_type)
{
	t_ast   *node;

    node = safe_malloc(sizeof(t_ast));
    node->type = AST_REDIRECT;
	node->left = cmd;
	node->right = NULL;
	node->argv = NULL;
	node->file = file;
	node->redirect_type = redirect_type;
	node->children = NULL;
	return (node);
}
// Logic AND/OR node constructor
t_ast *ast_new_and(t_ast *left, t_ast *right)
{
	t_ast   *node;

    node = safe_malloc(sizeof(t_ast));
    node->type = AST_AND;
    node->left = left;
    node->right = right;
    node->argv = NULL;
    node->file = NULL;
    node->redirect_type = 0;
    node->children = NULL;
    return (node);
}

t_ast *ast_new_or(t_ast *left, t_ast *right)
{
    t_ast   *node;

    node = safe_malloc(sizeof(t_ast));
    node->type = AST_OR;
    node->left = left;
    node->right = right;
    node->argv = NULL;
    node->file = NULL;
    node->redirect_type = 0;
    node->children = NULL;
    return (node);
}

// Subshell node constructor
t_ast *ast_new_subshell(t_ast *child)
{
    t_ast   *node;

    node = malloc(sizeof(t_ast));
    node->type = AST_SUBSHELL;
    node->left = child;
    node->right = NULL;
    node->argv = NULL;
    node->file = NULL;
    node->redirect_type = 0;
    node->children = NULL;
    return (node);
}
/*
Token Utilities (in Parser)
------------------------------
t_token *token_next_word(t_token *tok);
Skips non-word tokens, returns next word token.

t_token *token_skip_until(t_token *tok, t_token_type type);
Skips tokens until it finds a desired type (e.g., pipe, redirect).
*/

#include "nanoshell.h"

t_token *token_next_word(t_token *token)
{
    while (token && token->type != TOKEN_WORD)
        token = token->next;
    return (token);
}

t_token *token_skip_until(t_token *token, t_token_type type)
{
    while (token && token->type != type)
        token = token->next;
    return (token);
}/*

AST List Management (for N-ary nodes)
----------------------------------------
t_ast_list *ast_list_new(t_ast *node); ✅
Creates a new list node.

t_ast_list *ast_list_append(t_ast_list *head, t_ast *node); ✅
Appends a node to the end of a children list.

Command Argument Utilities
-----------------------------------------
int ast_count_args(char **argv);          ✅
Returns argument count for a command's argv.

*/

#include "nanoshell.h"

//void ast_list_free(t_ast_list *list);
//void ast_free(t_ast *node);

// AST List Management

// Creates a new list node.
t_ast_list *ast_list_new(t_ast *node)
{
	t_ast_list	*list;

	list = safe_malloc(sizeof(t_ast_list));
	list->node = node;
	list->next = NULL;
	return (list);
}

// Appends a node to the end of a children list.
t_ast_list *ast_list_append(t_ast_list *head, t_ast *node)
{
	t_ast_list	*tmp;
	t_ast_list	*new_node;

	if (!node)
		return (head);
	new_node = ast_list_new(node);
	if (!head)
		return (new_node);
	tmp = head;
	while (tmp->next)
		tmp = tmp->next;
	tmp->next = new_node;
	return (head);
}

// for commands
int ast_count_args(char **argv)
{
    int count;

    count = 0;
    while (argv[count])
        count++;
    return (count);

}



/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   display_token.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/13 13:02:42 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/13 13:15:50 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

static const char *type_to_str(t_token_type t)
{
    if (t == TOKEN_WORD) return ("WORD");
    if (t == TOKEN_PIPE) return ("PIPE");
    if (t == TOKEN_REDIR_IN) return ("REDIR_IN");
    if (t == TOKEN_REDIR_OUT) return ("REDIR_OUT");
    if (t == TOKEN_REDIR_APPEND) return ("REDIR_APPEND");
    if (t == TOKEN_HEREDOC) return ("HEREDOC");
    if (t == TOKEN_AND) return ("AND");
    if (t == TOKEN_OR) return ("OR");
    if (t == TOKEN_LPAREN) return ("LPAREN");
    if (t == TOKEN_RPAREN) return ("RPAREN");
    if (t == TOKEN_EOF) return ("EOF");
    if (t == TOKEN_ERROR) return ("ERROR");
    return ("UNKNOWN");
}


static const char *quote_to_str(t_quote_type q)
{
    if (q == QT_NONE)   return ("NONE");
    if (q == QT_SINGLE) return ("SINGLE");
    if (q == QT_DOUBLE) return ("DOUBLE");
    if (q == QT_MIXED)  return ("MIXED");
    return ("UNKNOWN");
}


const char *display_text_for_token(const t_token *t)
{
	if (t == NULL)
		return "";

	if (t->text && t->text[0] != '\0')
		return t->text;

	switch (t->type)
	{
		case TOKEN_PIPE: return "|";
		case TOKEN_REDIR_OUT: return ">";
		case TOKEN_REDIR_APPEND: return ">>";
		case TOKEN_REDIR_IN: return "<";
		case TOKEN_HEREDOC: return "<<";
		case TOKEN_AND: return "&&";
		case TOKEN_OR: return "||";
		case TOKEN_LPAREN: return "(";
		case TOKEN_RPAREN: return ")";
		case TOKEN_EOF: return "EOF";
		case TOKEN_ERROR: return "ERROR";
		case TOKEN_WORD:
		default:
			return "";
	}
}


static void print_escaped(const char *s)
{
	if (!s)
	{
		printf("(null)");
		return;
	}
	while (*s)
	{
		unsigned char c = (unsigned char)*s;
		switch (c)
		{
			case '\n': printf("\\n"); break;
			case '\r': printf("\\r"); break;
			case '\t': printf("\\t"); break;
			case '\b': printf("\\b"); break;
			case '\a': printf("\\a"); break;
			case '\v': printf("\\v"); break;
			case '\\': printf("\\\\"); break;
			case '\"': printf("\\\""); break;
			default:
				if (isprint(c))
					putchar(c);
				else
					printf("\\x%02x", c);
				break;
		}
		s++;
	}
}


void tokens_print_simple(const t_token *head)
{
	const t_token *cur = head;
	int idx = 1;

	while (cur)
	{
		const char *raw = cur->text;
		const char *display = display_text_for_token(cur);

		printf("token%-3d type=%-12s pos=%4zu quote=%-6s raw=\"",
			   idx, type_to_str(cur->type), cur->pos, quote_to_str(cur->quote));
		print_escaped(raw);
		printf("\" display=\"%s\"", display ? display : "");
		if (cur->type == TOKEN_ERROR)
			printf("  <-- ERROR");
		printf("\n");

		cur = cur->next;
		idx++;
	}
}


void tokens_print_simple_array(const t_token **arr, size_t count)
{
	size_t i;
	for (i = 0; i < count; ++i)
	{
		const t_token *t = arr[i];
		if (!t)
		{
			printf("token%zu: (NULL)\n", i + 1);
			continue;
		}
		printf("token%-3zu type=%-12s pos=%4d quote=%-6s raw=\"",
			   i + 1,
			   type_to_str(t->type),
			   (int)t->pos,
			   quote_to_str(t->quote));
		print_escaped(t->text);
		printf("\" display=\"%s\"\n", display_text_for_token(t));
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   token_quotes.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/12 13:50:51 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/13 14:27:58 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

int	parse_single_quote(t_buf *buf, const char *line, size_t *i, size_t len)
{
	while (*i < len && line[*i] != '\'')
	{
		if (buf_append_char(buf, line[*i]) < 0)
			return (-1);
		(*i)++;
	}
	if (*i >= len)
		return (-1);
	(*i)++;
	return (0);
}

int parse_double_quote(t_buf *buf, const char *line, size_t *i, size_t len, int last_status)
{
	while (*i < len && line[*i] != '"')
	{
		if (line[*i] == '\\' && (*i + 1) < len)
		{
			(*i)++;
			if (buf_append_char(buf, line[*i]) < 0) return (-1);
			(*i)++;
			continue;
		}
		if (line[*i] == '$')
		{
			if (expand_dollar(buf, line, i, len, last_status) < 0) return (-1);
			continue;
		}
		if (buf_append_char(buf, line[*i]) < 0) return (-1);
		(*i)++;
	}
	if (*i >= len) return (-1);
	(*i)++;
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   token_words.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/12 14:06:18 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/12 15:03:28 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

static t_quote_type quote_type_from_flags(int seen_single, int seen_double, int seen_unquoted)
{
	if ((seen_single && seen_double) ||
	    (seen_single && seen_unquoted) ||
	    (seen_double && seen_unquoted))
		return (QT_MIXED);
	if (seen_single)
		return (QT_SINGLE);
	if (seen_double)
		return (QT_DOUBLE);
	if (seen_unquoted)
		return (QT_NONE);
	return (QT_NONE);
}

static t_token	*finalize_token_from_ctx(size_t start, t_word_ctx *ctx)
{
	char			*text;
	t_quote_type	qt;

	text = buf_release(&ctx->buf);
	if (!text)
		return (NULL);
	qt = quote_type_from_flags(ctx->seen_single, ctx->seen_double, ctx->seen_unquoted);
	return (token_new(TOKEN_WORD, text, qt, (int)start));
}

static t_token *build_word_token(const char *line, size_t *i, size_t len, size_t start, int last_status)
{
    t_word_ctx ctx;
    int rc;
    t_token *tok;

    ctx.seen_single = 0;
    ctx.seen_double = 0;
    ctx.seen_unquoted = 0;
    buf_init(&ctx.buf);

    rc = process_chars_ctx(&ctx, line, i, len, last_status);
    if (rc != 0)
    {
        if (rc == -1)
            return (make_error_token_from_ctx(start, "unclosed single quote", &ctx));
        if (rc == -2)
            return (make_error_token_from_ctx(start, "unclosed double quote", &ctx));
        free(ctx.buf.data);
        return (NULL);
    }
    tok = finalize_token_from_ctx(start, &ctx);
    return (tok);
}

t_token	*parse_word(const char *line, size_t *i, size_t len, int last_status)
{
	size_t	start;

	if (!line || !i)
		return (NULL);
	start = *i;
	return (build_word_token(line, i , len, start, last_status));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   token_operator.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/13 13:00:48 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/13 14:16:58 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

static t_token *handle_greater(const char *line, size_t *i, size_t len, size_t pos)
{
    if (*i + 1 < len && line[*i + 1] == '>')
    {
        *i += 2;
        return (token_new(TOKEN_REDIR_APPEND, ft_strdup(">>"), QT_NONE, pos));
    }
    *i += 1;
    return (token_new(TOKEN_REDIR_OUT, ft_strdup(">"), QT_NONE, pos));
}
static t_token	*handle_less(const char *line, size_t *i, size_t len, size_t pos)
{
    if (*i + 1 < len && line[*i + 1] == '<' )
    {
        *i += 2;
        return (token_new(TOKEN_HEREDOC, ft_strdup("<<"), QT_NONE, pos));
    }
    *i += 1;
    return (token_new(TOKEN_REDIR_IN, ft_strdup("<"), QT_NONE, pos));
}

static t_token	*handle_pipe_or_or(const char *line, size_t *i, size_t len, size_t pos)
{
    if (*i + 1 < len && line[*i + 1] == '|')
	{
		*i += 2;
		return (token_new(TOKEN_OR, ft_strdup("||"), QT_NONE, pos));
	}
	*i += 1;
    return (token_new(TOKEN_PIPE, ft_strdup("|"), QT_NONE, pos));
}

static t_token	*handle_and_or_amp(const char *line, size_t *i, size_t len, size_t pos)
{
	if (*i + 1 < len && line[*i + 1] == '&')
	{
		*i += 2;
		return (token_new(TOKEN_AND, ft_strdup("&&"), QT_NONE, pos));
	}
	*i += 1;
	return (token_new(TOKEN_WORD, ft_strdup("&"), QT_NONE, pos));
}

static t_token	*handle_paren(const char *line, size_t *i, size_t len, size_t pos)
{
	(void)len;
	if (line[*i] == '(')
	{
		*i += 1;
		return (token_new(TOKEN_LPAREN, ft_strdup("("), QT_NONE, pos));
	}
	*i += 1;
	return (token_new(TOKEN_RPAREN, ft_strdup(")"), QT_NONE, pos));
}

t_token *parse_operator(const char *line, size_t *i, size_t len)
{
    size_t pos;

    if (!line || !i)
        return (NULL);
    pos = *i;
    if (line[*i] == '>') {
		return (handle_greater(line, i, len, pos));}
    if (line[*i] == '<') {
        return (handle_less(line, i, len, pos));}
    if (line[*i] == '|') {
        return (handle_pipe_or_or(line, i, len, pos));}
	if (line[*i] == '&') {
		return (handle_and_or_amp(line, i, len, pos));}
	if (line[*i] == '(' || line[*i] == ')'){
		return (handle_paren(line, i, len, pos));}
    return (NULL);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   token_utils.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/08 14:35:49 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/12 14:40:08 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

t_token	*token_new(t_token_type type, char *text, t_quote_type qt, int pos)
{
	t_token	*t = malloc(sizeof(t_token));
	if (!t)
	{
		free(text);
		return (NULL);
	}
	t->type = type;
	t->text = text;
	t->quote = qt;
	t->pos = pos;
	t->next = NULL;
	return	(t);
}

void	token_append(t_token **head, t_token *node)
{
	t_token	*cur;

	if (!node)
		return ;
	if (!*head)
	{
		*head = node;
		return ;
	}
	cur = *head;
	while (cur->next)
		cur = cur->next;
	cur->next = node;
}

void	free_tokens(t_token *head)
{
	t_token *cur;
	t_token	*n;

	cur = head;
	while (cur)
	{
		n = cur->next;
		if (cur->text)
			free(cur->text);
		free(cur);
		cur = n;
	}
}

t_token	*make_error_token_from_ctx(size_t start, const char *msg, t_word_ctx *ctx)
{
	char	*m;

	free(ctx->buf.data);
	m = ft_strdup(msg);
	if (!m)
		return (NULL);
	return (token_new(TOKEN_ERROR, m, QT_NONE, (int)start));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   buffer_utils.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/08 15:51:26 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/12 15:09:49 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

int buf_append_str(t_buf *b, const char *s)
{
	size_t slen;

	if (!b || !s)
		return (0);
	slen = ft_strlen(s);
	if (slen == 0)
		return (0);
	if (buf_ensure_capacity(b, b->len + slen + 1) != 0)
		return (-1);
	ft_memcpy(b->data + b->len, s, slen);
	b->len += slen;
	b->data[b->len] = '\0';
	return (0);
}

void	buf_init(t_buf *b)
{
	b->data = NULL;
	b->len = 0;
	b->cap = 0;
}

void	buf_free(t_buf *b)
{
	if (!b)
		return ;
	free(b->data);
	b->data = NULL;
	b->len = 0;
	b->cap = 0;
}

static size_t	next_capacity(size_t cur, size_t min_needed)//calcular la siguente  capacidad
{
	size_t	ncap;

	if (min_needed == 0)
		return (0);
	if (cur == 0)
		ncap = 32;
	else
	{
		ncap = cur * 2;
	}
	while (ncap < min_needed)
	{
		if (ncap > SIZE_MAX / 2)
		{
			ncap = min_needed;//si doblar espacio causa over
			break ;//      le adjudicamos el min necesario
		}
		ncap *= 2;
	}
	if (ncap < min_needed)
		ncap = min_needed;
	return (ncap);
}

int	buf_ensure_capacity(t_buf *b, size_t min_needed)//aumenta tamanio buffer
{
	size_t	ncap;
	char	*n;

	if (!b)
		return (-1);
	if (b->cap >= min_needed)
		return (0);
	ncap = next_capacity(b->cap, min_needed);
	n = malloc(ncap);
	if (!n)
		return (-1);
	if (b->data && b->len > 0)
		ft_memcpy(n, b->data, b->len + 1);
	else
	{
		n[0] = '\0';
	}
	free(b->data);
	b->data = n;
	b->cap = ncap;
	return (0);
}

int	buf_append_char(t_buf *b, char c)//aniade un caracter al buffer asegura espacio para char + '\\0'
{
	size_t	required;

	if (!b)
		return (-1);
	required = b->len + 2; //nuevo char mas terminador
	if (buf_ensure_capacity(b, required) != 0)
		return (-1);
	b->data[b->len++] = c;
	b->data[b->len] = '\0';
	return (0);
}

char	*buf_release(t_buf *buf)
{
	char *ret;

	if (!buf)
		return (NULL);
	if (buf->data == NULL)
	{
		ret = malloc(1);
		if (!ret)
			return (NULL);
		ret[0] = '\0';
		buf->len = 0;
		buf->cap = 0;
		return (ret);
	}
	ret = buf->data;
	buf->data = NULL;
	buf->len = 0;
	buf->cap = 0;
	return (ret);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expand_handlers.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/29 11:51:07 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/29 11:51:12 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

static int append_env_by_name(t_buf *buf, const char *name)
{
	const char *val;
	int rc;

	if (!buf || !name)
		return (0);
	val = getenv(name);
	if (!val)
		return (0);
	rc = buf_append_str(buf, val);
	if (rc < 0)
		return (-1);
	return (0);
}

static int append_literal_range(t_buf *buf, const char *line, size_t start,
								size_t end)
{
	while (start < end)
	{
		if (buf_append_char(buf, line[start]) < 0)
			return (-1);
		start++;
	}
	return (0);
}

static int braced_unclosed_append(t_buf *buf, const char *line, size_t start,
								  size_t current)
{
	if (!buf || !line)
		return (-1);
	if (buf_append_char(buf, '$') < 0)
		return (-1);
	if (buf_append_char(buf, '{') < 0)
		return (-1);
	if (append_literal_range(buf, line, start, current) < 0)
		return (-1);
	return (0);
}

int handle_braced(t_buf *buf, const char *line, size_t *i, size_t len)
{
	size_t start;
	size_t idlen;
	char *name;
	int rc;

	if (!buf || !line || !i)
		return (-1);
	(*i)++;
	start = *i;
	idlen = parse_identifier_len(line, *i, len);
	*i += idlen;
	if (*i >= len || line[*i] != '}')
		return (braced_unclosed_append(buf, line, start, *i));
	name = ft_strndup(line + start, idlen);
	if (!name)
		return (-1);
	(*i)++;
	rc = append_env_by_name(buf, name);
	free(name);
	if (rc < 0)
		return (-1);
	return (0);
}

int handle_simple(t_buf *buf, const char *line, size_t *i, size_t len)
{
	size_t idlen;
	char *name;
	int rc;

	if (!buf || !line || !i)
		return (-1);
	idlen = parse_identifier_len(line, *i, len);
	if (idlen == 0)
	{
		if (buf_append_char(buf, '$') < 0)
			return (-1);
		return (0);
	}
	name = ft_strndup(line + *i, idlen);
	if (!name)
		return (-1);
	*i += idlen;
	rc = append_env_by_name(buf, name);
	free(name);
	if (rc < 0)
		return (-1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   process_chars_ctx.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/29 11:52:54 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/29 11:52:58 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

int handle_single_quote(t_word_ctx *ctx, const char *line,
                               size_t *i, size_t len)
{
	if (!ctx || !line || !i)
		return (-1);
	ctx->seen_single = 1;
	(*i)++;
	if (parse_single_quote(&ctx->buf, line, i, len) < 0)
		return (-1);
	return (0);
}


int handle_double_quote(t_word_ctx *ctx, const char *line,
                               size_t *i, size_t len, int last_status)
{
	if (!ctx || !line || !i)
		return (-2);
	ctx->seen_double = 1;
	(*i)++;
	if (parse_double_quote(&ctx->buf, line, i, len, last_status) < 0)
		return (-2);
	return (0);
}

int handle_dollar(t_word_ctx *ctx, const char *line,
                         size_t *i, size_t len, int last_status)
{
	if (!ctx || !line || !i)
		return (-4);
	if (expand_dollar(&ctx->buf, line, i, len, last_status) < 0)
		return (-4);
	return (0);
}

int handle_regular_char(t_word_ctx *ctx, const char *line, size_t *i)
{
	if (!ctx || !line || !i)
		return (-3);
	ctx->seen_unquoted = 1;
	if (buf_append_char(&ctx->buf, line[*i]) < 0)
		return (-3);
	(*i)++;
	return (0);
}




/*
void dbg_buf_print(const t_word_ctx *ctx)
{
    const char *d = ctx->buf.data ? ctx->buf.data : "(null)";
    fprintf(stderr, "[DBG] buf=\"%s\" seen_s=%d seen_d=%d seen_u=%d\n",
            d, ctx->seen_single, ctx->seen_double, ctx->seen_unquoted);
}

 Loop principal con trazas
int process_chars_ctx(t_word_ctx *ctx, const char *line,
                             size_t *i, size_t len, int last_status)
{
    int rc;
    fprintf(stderr, "[DBG] process_chars_ctx start i=%zu len=%zu\n", *i, len);
    while (*i < len && !is_space((char)line[*i]) &&
           !is_operator((char)line[*i]))
    {
        rc = dispatch_char(ctx, line, i, len, last_status);
        if (rc != 0)
        {
            fprintf(stderr, "[DBG] process_chars_ctx returning rc=%d i=%zu\n", rc, *i);
            return (rc);
        }
    }
    fprintf(stderr, "[DBG] process_chars_ctx done i=%zu\n", *i);
    return (0);
}

*/
int process_chars_ctx(t_word_ctx *ctx, const char *line,
                             size_t *i, size_t len, int last_status)
{
	int rc;

	while (*i < len && !is_space((char)line[*i]) &&
		   !is_operator((char)line[*i]))
	{
		rc = dispatch_char(ctx, line, i, len, last_status);
		if (rc != 0)
			return (rc);
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expand.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/29 11:50:38 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/29 11:50:47 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

int expand_special_status(t_buf *buf, size_t *i, int last_status)
{
	char *s;
	int  rc;

	if (!buf || !i)
		return (-1);
	s = ft_itoa(last_status);
	if (!s)
		return (-1);
	rc = buf_append_str(buf, s);
	free(s);
	if (rc < 0)
		return (-1);
	(*i)++;
	return (0);
}

int expand_special_pid(t_buf *buf, size_t *i)
{
	char *s;
	int  rc;

	if (!buf || !i)
		return (-1);
	s = ft_itoa((int)getpid());
	if (!s)
		return (-1);
	rc = buf_append_str(buf, s);
	free(s);
	if (rc < 0)
		return (-1);
	(*i)++;
	return (0);
}

int expand_dollar(t_buf *buf, const char *line, size_t *i, size_t len,
                  int last_status)
{
	if (!buf || !line || !i)
		return (-1);
	if (*i >= len || line[*i] != '$')
		return (0);
	(*i)++;
	if (*i >= len)
	{
		if (buf_append_char(buf, '$') < 0)
			return (-1);
		return (0);
	}
	if (line[*i] == '?')
		return (expand_special_status(buf, i, last_status));
	if (line[*i] == '$')
		return (expand_special_pid(buf, i));
	if (line[*i] == '{')
		return (handle_braced(buf, line, i, len));
	return (handle_simple(buf, line, i, len));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokenizer.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/13 13:31:36 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/13 13:32:43 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

static int  append_operator(const char *line, size_t *i, size_t len, t_token **head)
{
    t_token *op;

    op = parse_operator(line, i, len);
    if (!op)
    {
        free_tokens(*head);
        return (0);
    }
    token_append(head, op);
    return (1);
}

static int  append_word(const char *line, size_t *i, size_t len, t_token **head, int last_status)
{
    t_token *word;

    word = parse_word(line, i, len, last_status);
    if (!word)
    {
        free_tokens(*head);
        return (0);
    }
    token_append(head, word);
    return (1);
}

t_token *tokenizer(const char *line, int last_status)
{
    t_token *head;
    size_t  i;
    size_t  len;

    if (!line)
        return NULL;
    len = ft_strlen(line);
    head = NULL;
    i = 0;
    while (i < len)
    {
        skip_spaces(line, &i, len);
        if (i >= len)
            break ;
        if (line[i] == '<' || line[i] == '>' || line[i] == '|' ||
            line[i] == '&' || line[i] == '(' || line[i] == ')')
        {
            if (!append_operator(line, &i, len, &head))
                return (NULL);
            continue;
        }
        if (!append_word(line, &i, len, &head, last_status))
            return (NULL);
    }
    return (head);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   process_chars_ctx_handlers.c                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/29 11:52:05 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/29 11:52:15 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

/* Dispatch con trazas

int dispatch_char(t_word_ctx *ctx, const char *line, size_t *i, size_t len, int last_status)
{
    char c = line[*i];
    fprintf(stderr, "[DBG] dispatch at i=%zu char='%c' (0x%02x)\n", *i, c, (unsigned char)c);
    dbg_buf_print(ctx);

    if (c == '\'')
    {
        int rc = handle_single_quote(ctx, line, i, len);
        fprintf(stderr, "[DBG] after handle_single_quote -> rc=%d i=%zu\n", rc, *i);
        dbg_buf_print(ctx);
        return rc;
    }
    if (c == '"')
    {
        int rc = handle_double_quote(ctx, line, i, len, last_status);
        fprintf(stderr, "[DBG] after handle_double_quote -> rc=%d i=%zu\n", rc, *i);
        dbg_buf_print(ctx);
        return rc;
    }
    if (c == '$')
    {
        int rc = handle_dollar(ctx, line, i, len, last_status);
        fprintf(stderr, "[DBG] after handle_dollar -> rc=%d i=%zu\n", rc, *i);
        dbg_buf_print(ctx);
        return rc;
    }
    if (c == '\\')
    {
        int rc = handle_backslash_outside(ctx, line, i, len);
        fprintf(stderr, "[DBG] after handle_backslash_outside -> rc=%d i=%zu\n", rc, *i);
        dbg_buf_print(ctx);
        return rc;
    }
    {
        int rc = handle_regular_char(ctx, line, i);
        fprintf(stderr, "[DBG] after handle_regular_char -> rc=%d i=%zu appended='%c'\n",
                rc, *i, (unsigned char)line[(*i>0)?(*i-1):0]);
        dbg_buf_print(ctx);
        return rc;
    }
}
*/

int dispatch_char(t_word_ctx *ctx, const char *line, size_t *i, size_t len, int last_status)
{
    char c = line[*i];

    if (c == '\'')
        return (handle_single_quote(ctx, line, i, len));
    if (c == '"')
        return (handle_double_quote(ctx, line, i, len, last_status));
    if (c == '$')
        return (handle_dollar(ctx, line, i, len, last_status));
    if (c == '\\')
        return (handle_backslash_outside(ctx, line, i, len));
    return (handle_regular_char(ctx, line, i));
}

int handle_backslash_outside(t_word_ctx *ctx, const char *line, size_t *i, size_t len)
{
    ctx->seen_unquoted = 1;
    (*i)++;
    if (*i < len)
    {
        if (buf_append_char(&ctx->buf, line[*i]) < 0)
            return (-3);
        (*i)++;
        return (0);
    }
    if (buf_append_char(&ctx->buf, '\\') < 0)
        return (-3);
    return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   handle_brace_utils.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/29 11:51:32 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/29 11:51:40 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

size_t parse_identifier_len(const char *line, size_t i, size_t len)
{
    size_t n;

    if (!line || i >= len)
        return (0);
    if (!((line[i] >= 'A' && line[i] <= 'Z') ||
          (line[i] >= 'a' && line[i] <= 'z') ||
          (line[i] == '_')))
        return (0);
    n = 0;
    while (i + n < len)
    {
        char c = line[i + n];
        if (!((c >= 'A' && c <= 'Z') ||
              (c >= 'a' && c <= 'z') ||
              (c >= '0' && c <= '9') ||
              (c == '_')))
            break ;
        n++;
    }
    return (n);
}

char *ft_strndup(const char *s, size_t n)
{
    char *out;

    if (!s)
        return (NULL);
    out = malloc(n + 1);
    if (!out)
        return (NULL);
    ft_memcpy(out, s, n);
    out[n] = '\0';
    return (out);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   run_multi_pipes.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/29 11:58:42 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/29 13:33:53 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

static void parent_close_intermediates(int (*pipes)[2], int n)
{
    int i;

    if (!pipes || n <= 1)
        return ;
    i = 0;
    while (i < n - 1)
    {
        if (pipes[i][0] >= 0)
        {
            close(pipes[i][0]);
            pipes[i][0] = -1;
        }
        if (pipes[i][1] >= 0)
        {
            close(pipes[i][1]);
            pipes[i][1] = -1;
        }
        i++;
    }
}

int  spawn_all_children(t_ast **cmds, int n, int (*pipes)[2], t_data *data, pid_t *pids)
{
    int i;
    int in_fd;
    int out_fd;

    i = 0;
    while (i < n)
    {
        in_fd = -1;
        out_fd = -1;
        if (i > 0)
            in_fd = pipes[i - 1][0];
        if (i < n - 1)
            out_fd = pipes[i][1];
        pids[i] = spawn_child(cmds[i], in_fd, out_fd, data);
        if (pids[i] == -1)
            return (-1);
        i++;
    }
    return (0);
}

int  create_pipes(int (*pipes)[2], int n)
{
    int i;
    int j;

    i = 0;
    while (i <  n - 1)
    {
        while (pipe(pipes[i]) == -1)
        {
            if (errno == EINTR)
                continue;
            j = 0;
            while (j < i)
            {
                if (pipes[j][0] >= 0)
                    close(pipes[j][0]);
                if (pipes[j][1] >= 0)
                    close(pipes[j][1]);
                j++;
            }
            return (-1);
        }
        i++;
    }
    return (0);
}

int allocate_resources(int n, int (*(*pipes_out))[2], pid_t **pids_out)
{
	int (*pipes)[2];
	pid_t *pids;
	int i;

	pipes = safe_malloc(sizeof(int[2]) * (n - 1));
	pids = safe_malloc(sizeof(pid_t) * n);
	i = 0;
	while (i < n - 1)
	{
		pipes[i][0] = -1;
		pipes[i][1] = -1;
		i++;
	}
	i = 0;
	while (i < n)
	{
		pids[i] = 0;
		i++;
	}
	*pipes_out = pipes;
	*pids_out = pids;
	return (0);
}

int run_multi(t_ast **cmds, int n, t_data *data)
{
	int (*pipes)[2];
	pid_t *pids;
	int status;

	if (n < 2)
		return (run_single(cmds[0], data));
	if (setup_resources(n, &pipes, &pids, data) == -1)
		return (127);
	if (spawn_children_checked(cmds, n, pipes, data, pids) == -1)
	{
		teardown_resources(pipes, pids, n, data);
		return (127);
	}
	parent_close_intermediates(pipes, n);
	status = wait_for_all(pids, n);
	teardown_resources(pipes, pids, n, data);
	return (status);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipe_utils.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/29 11:58:13 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/29 11:58:17 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

pid_t wait_one(pid_t pid, int *st)
{
	pid_t w;

	if (pid <= 0 || !st)
		return (-1);
	while ((w = waitpid(pid, st, 0)) == -1 && errno == EINTR)
		;
	return (w);
}

int status_to_code(int s)
{
	if (WIFEXITED(s))
		return (WEXITSTATUS(s));
	if (WIFSIGNALED(s))
		return (128 + WTERMSIG(s));
	return (s);
}

int spawn_children_checked(t_ast **cmds, int n, int (*pipes)[2],
				  t_data *data, pid_t *pids)
{
	if (spawn_all_children(cmds, n, pipes, data, pids) == -1)
	{
		wait_for_all(pids, n);
		close_all_pipes(pipes, n);
		return (-1);
	}
	return (0);
}

int setup_resources(int n, int (*(*pipes_out))[2], pid_t **pids_out, t_data *data)
{
	int (*pipes)[2];
	pid_t *pids;

	if (allocate_resources(n, &pipes, &pids) == -1)
		return (-1);
	if (data)
	{
		data->pipes = pipes;
		data->pipes_count = n;
	}
	if (create_pipes(pipes, n) == -1)
	{
		close_all_pipes(pipes, n);
		free(pids);
		free(pipes);
		if (data)
		{
			data->pipes = NULL;
			data->pipes_count = 0;
		}
		return (-1);
	}
	*pipes_out = pipes;
	*pids_out = pids;
	return (0);
}

void teardown_resources(int (*pipes)[2], pid_t *pids, int n, t_data *data)
{
	if (pids)
		free(pids);
	if (pipes)
	{
		close_all_pipes(pipes, n);
		free(pipes);
	}
	if (data)
	{
		data->pipes = NULL;
		data->pipes_count = 0;
	}
}
/*
 ▄▄▄██▀▀▀    ▄▄▄          ██▒   █▓    ██▓   ▓█████     ██▀███  
   ▒██      ▒████▄       ▓██░   █▒   ▓██▒   ▓█   ▀    ▓██ ▒ ██▒
   ░██      ▒██  ▀█▄      ▓██  █▒░   ▒██▒   ▒███      ▓██ ░▄█ ▒
▓██▄██▓     ░██▄▄▄▄██      ▒██ █░░   ░██░   ▒▓█  ▄    ▒██▀▀█▄  
 ▓███▒       ▓█   ▓██▒      ▒▀█░     ░██░   ░▒████▒   ░██▓ ▒██▒
 ▒▓▒▒░       ▒▒   ▓▒█░      ░ ▐░     ░▓     ░░ ▒░ ░   ░ ▒▓ ░▒▓░
 ▒ ░▒░        ▒   ▒▒ ░      ░ ░░      ▒ ░    ░ ░  ░     ░▒ ░ ▒░
 ░ ░ ░        ░   ▒           ░░      ▒ ░      ░        ░░   ░ 
 ░   ░            ░  ░         ░      ░        ░  ░      ░     
                              ░                                

        EXEC_COMMAND.C
*/

#include "nanoshell.h"

int  wait_for_child(pid_t pid)
{
    int status;
    int ret;

    if (waitpid(pid, &status, 0) == -1)
    {
        perror("waitpid");
        return (127);
    }
    if (WIFEXITED(status))
        ret = WEXITSTATUS(status);
    else if (WIFSIGNALED(status))
        ret = 128 + WTERMSIG(status);
    else
        ret = status;
    return (ret);
}
// +128 para distinguir fallo por señal \ fallo por exit code.

void reset_sig_in_child(void)
{
    signal(SIGINT, SIG_DFL);
    signal(SIGQUIT, SIG_DFL);
}

void exec_child(t_ast *node, t_data *data)
{
    char    *path;

    if (!node || !node->argv || !node->argv[0])
        exit(127);
    path = find_path((char *)node->argv[0], data->envp);
    if (!path)
    {
        exec_error("command not found", node->argv[0]);
        exit(127);
    }
    reset_sig_in_child();
    execve(path, node->argv, data->envp);
    perror("execve");
    free(path);    
    exit(127);
}

int exec_command(t_ast *node, t_data *data)
{
    pid_t   pid;
    int     ret;

    if (!node || !data)
        return (127);
    pid = fork();
    if (pid < 0)
    {
        perror("fork");
        return (127);
    }
    if (pid == 0)
        exec_child(node, data);
    ret = wait_for_child(pid);
    return (ret);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_ast.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/29 11:54:31 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/29 15:25:45 by alemonto         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

static int  exec_or(t_ast *node, t_data *data)
{
    int status;

    if (!node || node->type != AST_OR)
        return (1);
    status = exec_ast(node->left, data);
    if ( status != 0)
        return (exec_ast(node->right, data));
    return (status);    
}

static int  exec_and(t_ast *node, t_data *data)
{
    int status;

        if (!node || node->type != AST_AND)
            return (1);
        status = exec_ast(node->left, data);
        if  (status == 0)
            return (exec_ast(node->right, data));
        return (status);
}

int	exec_ast(t_ast *node, t_data *data)
{
	int	status;

	if (!node)
		return (0);
	else if (node->type == AST_COMMAND)
		status = exec_command(node, data);
	else if (node->type == AST_AND)
		status = exec_and(node, data);
	else if (node->type == AST_OR)
		status = exec_or(node, data);
	else if (node->type == AST_PIPE)
		status = exec_pipeline(node, data);
	else if (node->type == AST_REDIRECT)
		status = apply_redirect_and_exec(node, data);
	//else if (node->type == AST_SUBSHELL)
		//return (exec_subshell(node, data));
	else
		status = 1;
	data->last_status = status;
	return (status);
}

#include "nanoshell.h"

void	exec_error(const char *message, const char *arg)
{
	write(2, "Executor: ", 10);
	write(2, message, ft_strlen_const(message));
	if (arg)
	{
		write(2, ":", 1);
		write(2, arg, ft_strlen_const(arg));
	}
	write(2, "\n", 1);
}

char *heredoc_tmp_name(void)
{
	static int	n;
	char		*num;
	char		*name;

	if (n < 0)
		n = 0;
	num = ft_itoa(n);
	if (!num)
		return (NULL);
	n++;
	name = ft_strjoin(".heredoc_", num);
	free(num);
	return (name);
}

char *create_heredoc_tmp(char *delimeter)
{
	char	*path;
	char	*line;
	int		fd;
	size_t	len_line;
	size_t	len_delim;

	path = heredoc_tmp_name();
	if (!path)
		return (NULL);
	// only your minishell user can read/write the file
	fd = open(path, O_WRONLY | O_CREAT | O_TRUNC, 0600);
	if (fd < 0)
	{
		exec_error("open failed", path);
		free(path);
		return (NULL);
	}
	while (1)
	{
		line = readline("> ");
		if (!line)
			break; // EOF
		len_line = ft_strlen(line);
		len_delim = ft_strlen(delimeter);
		if (len_line == len_delim && ft_strncmp(line, delimeter, len_delim) == 0)
		{
			free(line);
			break; // reached delimeter
		}
		write (fd, line, ft_strlen(line));
		write (fd, "\n", 1);
		free(line);
	}
	close(fd);
	return (path); 
}

#include "nanoshell.h"

int	apply_redirect_and_exec(t_ast *node, t_data *data)
{
	int		fd;
	pid_t	pid;
	int		status;
	int		ret;

	if (!node || !node->left)
		return (1);
	pid = fork();
	if (pid < 0)
	{
		// fork error
		exec_error("fork failed", NULL);
		return (1);
	}
	else if (pid == 0)
	{
		// CHILD: set up redirections, then execute node->left
		/* set fd depending on redirect_type */
		fd = -1; // default value
		if (node->redirect_type == TOKEN_REDIR_OUT)
		{
			// > Open file for writing, truncating if it exists
			fd = open(node->file, O_WRONLY | O_CREAT | O_TRUNC, 0644);
			if (fd < 0)
			{
				exec_error("open failed", node->file);
				exit(1);
			}
			if (dup2(fd, STDOUT_FILENO) < 0)
			{
				exec_error("dup2 failed", node->file);
				close(fd);
				exit(1);
			}
		}
		else if (node->redirect_type == TOKEN_REDIR_APPEND)
        {
            // >> Opens file for writing, and if it exists, appends to the end
			fd = open(node->file, O_WRONLY | O_CREAT | O_APPEND, 0644);
			if (fd < 0)
			{
				exec_error("open failed", node->file);
				exit(1);
			}
			if (dup2(fd, STDOUT_FILENO) < 0)
			{
				exec_error("dup2 failed", node->file);
				close(fd);
				exit(1);
			}		
        }
		else if (node->redirect_type == TOKEN_REDIR_IN)
        {
			// < Open file for reading
			fd = open(node->file, O_RDONLY);
			if (fd < 0)
			{
				exec_error("open failed", node->file);
				exit(1);
			}
			if (dup2(fd, STDIN_FILENO) < 0)
			{
				exec_error("dup2 failed", node->file);
				close(fd);
				exit(1);
			}
		}
		else if (node->redirect_type == TOKEN_HEREDOC)
        {
			// << Prepare a temporary file or pipe
			// write heredoc content into node->file
			fd = open(node->file, O_RDONLY);
			if (fd < 0)
			{
				exec_error("open failed", node->file);
				exit(1);
			}
			// The command will read its input from your heredoc, not from the terminal
			if (dup2(fd, STDIN_FILENO) < 0)
			{
				exec_error("dup2 failed", node->file);
				close(fd);
				exit(1);
			}
		}
		/* only close if it was actually opened */
		if (fd >= 0)
			close(fd);
		// now run the node->left command/subtree
		status = exec_ast(node->left, data);
		exit(status);
	}
	else
	{
		// PARENT: wait for child and return its status
		ret = wait_for_child(pid);
		if (node->redirect_type == TOKEN_HEREDOC && node->file)
			unlink(node->file); // delete tmp file
		data->last_status = ret;
    	return (data->last_status);
	}
}	
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_pipeline.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/29 11:55:29 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/29 11:55:32 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

static int  fill_children(t_ast_list *children, t_ast **ar)
{
    int i;

    i = 0;
    if (!ar)
        return (-1);
    while (children)
    {
        ar[i++] = children->node;
        children = children->next;
    }
    return (0);
}

static t_ast    **alloc_children(int n)
{
    if (n <= 0)
        return (NULL);
    return (safe_malloc(sizeof(t_ast *) * n));
}

static int  count_children(t_ast_list *children)
{
    int n;

    n = 0;
    while (children)
    {
        n++;
        children = children->next;
    }
    return (n);
}

static int  collect_children(t_ast_list *children, t_ast ***out_array)
{
    int n;

    if (!out_array)
        return (-1);
    n = count_children(children);
    if (n == 0)
    {
        *out_array = NULL;
        return (0);
    }
    *out_array = alloc_children(n);
    if (!*out_array)
        return (-1);
    if (fill_children(children, *out_array) == -1)
    {
        free(*out_array);
        *out_array = NULL;
        return (-1);
    }
    return (n);
}

int exec_pipeline(t_ast *node, t_data *data)
{
    t_ast   **cmds;
    int     n;
    int     status;

    if (!node || !data || !node->children)
        return (0);

    cmds = NULL;
    status = 0;
    n = collect_children(node->children, &cmds);
    if (n < 0)
        return (127);
    if (n == 0)
        return (0);
    if (n == 1)
        status = run_single(cmds[0], data);
    else
        status = run_multi(cmds, n, data);
    free(cmds);
    return (status);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   run_pipeline.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/29 11:59:11 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/29 13:54:47 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

static void	close_unused_pipe_fd(int (*pipes)[2], int n, int keep_in_fd, int keep_out_fd)
{
	int	i;

	if (!pipes || n <= 1)
		return ;
	i = 0;
	while (i < n - 1)
	{
		if (pipes[i][0] >= 0 && pipes[i][0] != keep_in_fd)
		{
			close(pipes[i][0]);
		}
		if (pipes[i][1] >= 0 && pipes[i][1] != keep_out_fd)
		{
			close(pipes[i][1]);
		}
		i++;
	}
}

static void child_exec(t_ast *cmd, char **envp)
{
    char    *path;

    if (!cmd || !cmd->argv || !cmd->argv[0])
        _exit(127);
    path = find_path((char *)cmd->argv[0], envp);
    if (!path)
    {
        exec_error("command not found", cmd->argv[0]);
        _exit(127);
    }
    execve(path, cmd->argv, envp);
    if (errno == EACCES)
        exec_error("permission denied", cmd->argv[0]);
    else
        exec_error("execve failed", cmd->argv[0]);
    free(path);
    if (errno == EACCES)
        _exit (126);
    else
        _exit(127);
}

static void child_reset_signals(void)
{
	signal(SIGINT, SIG_DFL);
	signal(SIGQUIT, SIG_DFL);
}

pid_t spawn_child(t_ast *cmd, int in_fd, int out_fd, t_data *data)
{
	pid_t pid;

	pid = fork();
	if (pid < 0)
		return (-1);
	if (pid == 0)
	{
		child_reset_signals();

		if (data)
			close_unused_pipe_fd(data->pipes, data->pipes_count, in_fd, out_fd);

		if (in_fd != -1)
		{
			if (dup2(in_fd, STDIN_FILENO) == -1)
				_exit(127);
		}

		if (out_fd != -1)
		{
			if (dup2(out_fd, STDOUT_FILENO) == -1)
				_exit(127);
		}

		if (in_fd != -1 && in_fd != STDIN_FILENO)
			close(in_fd);
		if (out_fd != -1 && out_fd != STDOUT_FILENO)
			close(out_fd);

		if (data)
			child_exec(cmd, data->envp);
		else
			child_exec(cmd, NULL);
		_exit(127);
	}
	return (pid);
}
/* tremenda fumada me he pegado.. esta funciion es inutil, bueno, sirve para el multipipe
me he liado a crear pipes cuando solo debia llamar a exec_comand... tecnoooloooogiiiaa...

int run_single(t_ast *cmd, t_data *data)
{
    int     pipefd[2];
    pid_t   pid;
    int     status;

    if (pipe(pipefd) == -1)
        return (exec_command(cmd, data));
    pid = spawn_child(cmd, data->envp, -1, pipefd[1]);
    if (pid == -1)
    {
        close(pipefd[0]);
        close(pipefd[1]);
        return (127);
    }
    close(pipefd[1]);
    forward_fd(pipefd[0]);
    status = wait_for_all(&pid, 1);
    return (status);
}
*/

int run_single(t_ast *cmd, t_data *data)
{
    (void)data;
    return (exec_command(cmd, data));
}
#include "nanoshell.h"

int exec_subshell(t_ast *node, t_data *data)
{
    pid_t   pid;
    int     status;

    if (!node || node->type != AST_SUBSHELL || !node->left)
        return (1);
    
    pid = fork();
    if (pid < 0)
    {
        perror("fork");
        return (1);
    }
    if (pid == 0)
    {
        // CHILD: run subshell body in a separate process
        reset_sig_in_child();
        status = exec_ast(node->left, data);
        exit(status);
    }
    // PARENT: wait and return subshell status
    return (wait_for_child(pid));
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   find_path.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/29 11:56:13 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/29 11:56:18 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

static char *join_dir_cmd(const char *dir, const char *cmd)
{
	size_t	dir_len;
	size_t	cmd_len;
	size_t	add_slash;
	size_t	need;
	char	*out;

	if (!calc_need_and_slash(dir, cmd, &need, &add_slash))
		return (NULL);
	dir_len = ft_strlen(dir);
	cmd_len = ft_strlen(cmd);
	out = malloc(need);
	if (!out)
		return (NULL);
	if (dir_len > 0)
		ft_memcpy(out, dir, dir_len);
	if (add_slash)
		out[dir_len] = '/';
	ft_memcpy(out + dir_len + add_slash, cmd, cmd_len);
	out[dir_len + add_slash + cmd_len] = '\0';
	return (out);
}

int  try_path_segment(const char *seg, const char *cmd, char ** out)
{
    char        *candidate;
    const char  *dir;

    if (!seg || !cmd || !out)
        return (0);
    if (*seg == '\0')
        dir = ".";
    else
        dir = seg;
    candidate = join_dir_cmd(dir, cmd);
    if (!candidate)
        return (0);
    if (access(candidate, X_OK) == 0)
    {
        *out = candidate;
        return (1);
    }
    free(candidate);
    return (0);
}

static char *search_path_segments(const char *path, const char *cmd)
{
    size_t  len;
    size_t  start;
    size_t  i;
    char    *res;
    int     rc;

    if (!path || !cmd)
        return (NULL);
    len = ft_strlen(path);
    start = 0;
    while (start <= len)
    {
        i = start;
        while (i < len && path[i] != ':')
            i++;
        rc = try_path_range(path, start, i, cmd, &res);
        if (rc == 1)
            return (res);
        if (rc == -1)
            return (NULL); /* propagar error de malloc */
        start = i + 1;
    }
    return (NULL);
}

static char *get_envp_path(char **envp)
{
    int i;

    if (!envp)
        return (NULL);
    i = 0;
    while (envp[i])
    {
        if (ft_strncmp(envp[i], "PATH=", 5) == 0)
            return (envp[i] + 5);
        i++;
    }
    return (NULL);
}

char    *find_path(char *cmd, char **envp)
{
    char    *path;

    if (!cmd || !*cmd)
        return (NULL);
    if (ft_strchr(cmd, '/'))
    {
        if (access(cmd, X_OK) == 0)
            return (ft_strdup(cmd));
        return (NULL);
    }
    path = get_envp_path(envp);
    if (!path)
        return (NULL);
   return (search_path_segments(path, cmd));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   find_path_helper.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/29 11:57:22 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/29 11:57:25 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

int	calc_need_and_slash(const char *dir, const char *cmd,
				size_t *need, size_t *add_slash)
{
	size_t dir_len;
	size_t cmd_len;

	if (!dir || !cmd || !need || !add_slash)
		return (0);
	dir_len = ft_strlen(dir);
	cmd_len = ft_strlen(cmd);
	if (dir_len == 0)
		*add_slash = 1;
	else if (dir[dir_len - 1] == '/')
		*add_slash = 0;
	else
		*add_slash = 1;
	if (cmd_len > SIZE_MAX - dir_len - *add_slash - 1)
		return (0);
	*need = dir_len + *add_slash + cmd_len + 1;
	return (1);
}

int try_path_range(const char *path, size_t start, size_t i,
                          const char *cmd, char **res)
{
    char *seg;
    int  ok;

    if (!path || !cmd || !res)
        return (0);
    if (i == start)
    {
        /* segmento vacío -> directorio actual */
        if (try_path_segment("", cmd, res))
            return (1);
        return (0);
    }
    seg = ft_strndup(path + start, i - start);
    if (!seg)
        return (-1); /* error de malloc */
    ok = try_path_segment(seg, cmd, res);
    free(seg);
    if (ok)
        return (1);
    return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipe_helpers.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/29 11:56:48 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/29 11:56:55 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

void close_all_pipes(int (*pipes)[2], int n)
{
	int i;

    i = 0;
    if (!pipes || n <= 0)
    {
        return ;
	}
    while (i < n - 1)
	{
		if (pipes[i][0] >= 0)
		{
			close(pipes[i][0]);
			pipes[i][0] = -1;
		}
		if (pipes[i][1] >= 0)
		{
			close(pipes[i][1]);
			pipes[i][1] = -1;
		}
		i++;
	}
}

int wait_for_all(pid_t *pids, int count)
{
    int     i;
    int     last;
    int     status;
    pid_t   w;

    if (!pids || count <= 0)
        return (0);
    i = 0;
    last = 0;
    while (i < count)
    {
        if (pids[i] > 0)
        {
            w = wait_one(pids[i], &status);
            if (w == -1)
                last = 127;
            else 
                last = status_to_code(status);
        }
        i++;
    }
    return (last);
}
/*
static ssize_t write_all(int fd, const void *buf, size_t count)
{
    const char *p;
    ssize_t     total;
    ssize_t     w;

    p = (const char *)buf;
    total = 0;
    while ((size_t)total < count)
    {
        w = write(fd, p + (size_t)total, count - (size_t)total);
        if (w == 0)
            return (-1);
        if (w == -1)
        {
            if (errno == EINTR)
                continue;
            return (-1);
        }
    total += w;
    }
    return (total);
}
static ssize_t  safe_read(int fd, void *buf, size_t count)
{
    ssize_t r;

    while (1)
    {
        r = read(fd, buf, count);
        if (r == -1)
        {
            if (errno == EINTR)
                continue;
            return (-1);
        }
        return (r);
    }
}


int forward_fd(int fd)   ESTO ERA UTIL PARA RUN_SINGLE, NOW IS TRASH
{
    char    buf[4096];
    ssize_t r;

    if (fd < 0)
        return (-1);
    while ((r = safe_read(fd, buf, sizeof(buf))) > 0)
    {
        if (write_all(STDOUT_FILENO, buf, (size_t)r) == -1)
        {
            close(fd);
            return (-1);
        }
    }
    if (r == -1)
    {
        close(fd);
        return (-1);
    }
    close(fd);
    return (0);
}
*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   basic_utils.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/08 13:57:34 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/13 14:30:04 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "nanoshell.h"

int	is_space(char c)
{
	if (c == ' ' || (c >= 9 && c <= 13))
		return (1);
	return (0);
}

int	is_operator(char c)
{
	if (c == '<' || c == '>' || c == '|' ||
		c == '&' || c == '(' || c == ')')
		return (1);
	return (0);
}

void    skip_spaces(const char *line, size_t *i, size_t len)
{
    while (*i < len && is_space(line[*i]))
        (*i)++;
}

void *safe_malloc(size_t size) 
{
    void *ptr = malloc(size);
    if (!ptr) {
        perror("Malloc failed");
        exit(EXIT_FAILURE);
    }
    return ptr;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   signals.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/11/29 11:49:50 by jadelgad          #+#    #+#             */
/*   Updated: 2025/11/29 11:49:56 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#define _XOPEN_SOURCE 700
#include <signal.h>
#include <string.h>
#include "nanoshell.h"

volatile sig_atomic_t g_signal_received = 0;

static void signal_handler(int signum) 
{
    if (signum == SIGINT)
    {
    	write(1, "\n", 1);		// move to a new line
    	rl_replace_line("", 0);  // Clear previous input text
    	rl_on_new_line();         // Move to new line
    	rl_redisplay();           // Redisplay prompt
    }
    g_signal_received = signum;  // Store the signal number
}

void    setup_signals(void)
{
    struct sigaction sa;
    memset(&sa, 0, sizeof(sa));
    sa.sa_handler = signal_handler;
    sa.sa_flags = 0; // default behavior
    sigemptyset(&sa.sa_mask); // don't block any signals in handler

    if (sigaction(SIGINT, &sa, NULL) == -1) 
    {
        perror("sigaction SIGINT");
    }
    if (sigaction(SIGQUIT, &sa, NULL) == -1) 
    {
        perror("sigaction SIGQUIT");
    }
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_atoi.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/08 12:20:37 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 08:08:53 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_atoi(const char *nptr)
{
	long	result;
	int		sign;
	int		i;

	i = 0;
	while (nptr[i] == ' ' || (nptr[i] >= 9 && nptr[i] <= 13))
		i++;
	sign = 1;
	if (nptr[i] == '-' || nptr[i] == '+')
	{
		if (nptr[i] == '-')
			sign = -1;
		i++;
	}
	result = 0;
	while (nptr[i] >= '0' && nptr[i] <= '9')
	{
		result = result * 10 + (nptr[i] - '0');
		i++;
	}
	return ((int)(result * sign));
}
/*
#include <stdio.h>

int	main()
{
	char *str = "  -42BCN";

	printf("%d\n", ft_atoi(str));
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlcpy.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/08 08:38:25 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/15 12:58:20 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"
#include <stddef.h>

size_t	ft_strlcpy(char *dst, const char *src, size_t n)
{
	size_t	i;
	size_t	j;

	i = 0;
	j = 0;
	while (src[i] != '\0')
		i++;
	if (n > 0)
	{
		while (j < n - 1 && src[j] != '\0')
		{
			dst[j] = src[j];
			j++;
		}
		dst[j] = '\0';
	}
	return (i);
}
/*
#include <stdio.h>

int	main()
{
	char	phrase1[] = "42BCN";
	char	phrase2[] = "to the moon";
	int		result;

	result = ft_strlcpy(phrase1, phrase2, 6);
	printf("%d\n", result);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strncmp.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/07 14:44:09 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/18 13:00:18 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_strncmp(const char *s1, const char *s2, size_t n)
{
	size_t	i;

	if (n == 0)
		return (0);
	i = 0;
	while (i < n -1 && s1[i] != '\0' && s2[i] != '\0')
	{
		if (s1[i] != s2[i])
			return ((unsigned char)s1[i] - (unsigned char)s2[i]);
		i++;
	}
	return ((unsigned char)s1[i] - (unsigned char) s2[i]);
}
/*
#include <stdio.h>

int	main()
{
	char *str1 = "42 to the Moon";
	char *str2 = "42 to the Sun";

	printf("%d\n", ft_strncmp(str1,str2, 50));
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memcmp.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/08 10:39:28 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/16 09:18:10 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_memcmp(const void *s1, const void *s2, size_t n)
{
	size_t			i;
	unsigned char	*str1;
	unsigned char	*str2;

	i = 0;
	str1 = (unsigned char *)s1;
	str2 = (unsigned char *)s2;
	while (i < n)
	{
		if (str1[i] != str2[i])
			return (str1[i] - str2[i]);
		i++;
	}
	return (0);
}
/*
#include <stdio.h>

int	main()
{
	char *str1 = "42 To the Moon";
	char *str2 = "42 to the Moon";

	printf("%d\n", ft_memcmp(str1, str2, 50));
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strdup.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/08 14:06:09 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/16 11:37:34 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_strdup(const char *s)
{
	char	*dst;
	size_t	len;

	len = ft_strlen(s);
	dst = ft_calloc(len + 1, sizeof(char));
	if (!dst)
		return (NULL);
	ft_strlcpy(dst, s, len + 1);
	return (dst);
}
/*
#include <stdio.h>

int	main()
{
	char	*str1 = "42BCn to the Moon!";

	printf("%s", ft_strdup(str1));
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isascii.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/05 15:15:43 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/15 10:39:29 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_isascii(int c)
{
	if (c >= 0 && c <= 127)
		return (1);
	else
		return (0);
}
/*
#include <stdio.h>

int	main()
{
	char	alpha;
	char	digit;
	char	alnum;
	char	print;

	alpha = 'a';
	digit = '1';
	alnum = 'a';
	print = '\n';
	printf("%d \n",ft_isscii(alpha));
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isalnum.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/05 15:04:28 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/15 10:38:26 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_isalnum(int c)
{
	if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))
		return (1);
	else if ((c >= '0') && (c <= '9'))
		return (1);
	else
		return (0);
}
/*
#include <stdio.h>

int	main()
{
	char	alpha;
	char	digit;
	char	alnum;
	char	print;

	alpha = 'a';
	digit = '1';
	alnum = 'a';
	print = '\n';
	printf("%d \n",ft_isalnum(alnum));
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memmove.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/07 11:19:58 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/18 13:05:04 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"
#include <stddef.h>

static void	ft_cpyforward(
	unsigned char *dst, const unsigned char *src, size_t n)
{
	size_t	i;

	i = 0;
	while (i < n)
	{
		dst[i] = src[i];
		i++;
	}
}

static void	ft_cpybackward(unsigned char *dst, const void *src, size_t n)
{
	const unsigned char	*s;

	s = (const unsigned char *)src;
	while (n-- > 0)
		dst[n] = s[n];
}

void	*ft_memmove(void *dest, const void *src, size_t n)
{
	unsigned char	*ptr_src;
	unsigned char	*ptr_dest;

	ptr_src = (unsigned char *)src;
	ptr_dest = (unsigned char *)dest;
	if (n == 0 || dest == src)
		return (dest);
	if (ptr_dest < ptr_src)
		ft_cpyforward(ptr_dest, ptr_src, n);
	else
		ft_cpybackward(ptr_dest, ptr_src, n);
	return (dest);
}
/*
#include <stdio.h>

int	main()
{
	char	dst[30];
	char	src[] = "42BCN to the Moon my Frate!";
	ft_memmove(dst, src, 10);
	printf("%s\n", dst);
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_bzero.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/07 08:24:01 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/15 11:25:12 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_bzero(void *s, size_t n)
{
	size_t			i;
	unsigned char	*ptr;

	i = 0;
	ptr = (unsigned char *)s;
	if (n == 0)
		return ;
	while (i < n)
	{
		ptr[i] = '\0';
		i++;
	}
}
/*
#include <stdio.h>

int	main()
{
	char	phrase[] = "42BCN to the moon";
	size_t len = 5;
	
	ft_bzero(phrase, len);
	printf("%c\n", phrase[3]);
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memset.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/05 15:58:50 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/15 11:11:35 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	*ft_memset(void *s, int c, size_t n)
{
	size_t			i;
	unsigned char	*ptr;

	ptr = (unsigned char *)s;
	i = 0;
	if (n == 0)
		return (s);
	while (i < n)
	{
		ptr[i] = (unsigned char) c;
		i++;
	}
	return (s);
}
/*
#include <stdio.h>

int	main()
{
	char phrase[] = "42BCN";
	char c;

	c = 'X';
	ft_memset(phrase, c, 2);
	printf("%s \n", phrase);
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_toupper.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/08 08:18:19 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/18 13:00:54 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_toupper(int c)
{
	if (c >= 97 && c <= 122)
		return (c - 32);
	return (c);
}

#include <stdio.h>

int	main()
{
	char	letter;
	char	result;

	letter = 'a';
	result = ft_toupper(letter);
	printf("%c\n", result);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memchr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/07 15:32:30 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/16 09:17:21 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	*ft_memchr(const void *s, int c, size_t n)
{
	size_t				i;
	const unsigned char	*ptr;

	i = 0;
	ptr = (const unsigned char *)s;
	while (i < n)
	{
		if (ptr[i] == (unsigned char)c)
			return ((void *)&ptr[i]);
		i++;
	}
	return (NULL);
}
/*
#include <stdio.h>

int	main()
{
	char	*str1 = "42 to the Moon!";
	char	letr = 'h';

	printf("%s\n", (char *)ft_memchr(str1, letr, 20));
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_substr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/09 16:33:27 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 08:14:27 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_substr(char const *s, unsigned int start, size_t len)
{
	size_t	s_len;
	size_t	i;
	char	*sub;

	i = 0;
	if (!s)
		return (NULL);
	s_len = ft_strlen(s);
	if (start >= s_len)
		return (ft_calloc(1, sizeof(char)));
	if (len > s_len - start)
		len = s_len - start;
	sub = ft_calloc(len + 1, sizeof(char));
	if (!sub)
		return (NULL);
	while (i < len)
	{
		sub[i] = s[i + start];
		i++;
	}
	return (sub);
}
/*
#include <stdio.h>

int	main()
{
	char	*str1 = "42BCN to the Moon!";

	printf("%s\n", ft_substr(str1, 6, 15));
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strchr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/07 12:59:51 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/13 12:52:51 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_strchr(const char *s, int c)
{
	int	i;

	i = 0;
	while (1)
	{
		if (s[i] == (char)c)
			return ((char *)(s + i));
		if (s[i] == '\0')
			break ;
		i++;
	}
	return (NULL);
}
/*
#include <stdio.h>
int	main()
{
	char	frase[30] = "ABCDEFGHIJK";
	int	letra = 'F';
	printf("%s\n",ft_strchr(frase, letra));
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putstr_fd.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/13 10:02:36 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 10:54:17 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */
#include "libft.h"

void	ft_putstr_fd(char *s, int fd)
{
	int	i;

	i = 0;
	if (!s)
		return ;
	while (s[i] != '\0')
	{
		write(fd, &s[i], 1);
		i++;
	}
}
/*
int	main()
{
	char	str1;

	str1[] = "42 to the Moon!";
	ft_putstr_fd(str1, 1);
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isdigit.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/05 14:12:00 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/15 10:37:02 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_isdigit(int c)
{
	if (c >= 48 && c <= 57)
		return (1);
	else
		return (0);
}
/*
#include <stdio.h>

int	main()
{
	char	alpha;
	char	digit;
	char	alnum;
	char	print;

	alpha = 'a';
	digit = '1';
	alnum = 'a';
	print = '\n';
	printf("%d \n",ft_isdigit(digit));
	return (0);
}
*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlen.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/05 12:02:56 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/15 10:58:14 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

size_t	ft_strlen(const char *s)
{
	int	i;

	i = 0;
	while (s[i] != '\0')
		i++;
	return (i);
}
/*
#include <stdio.h>

int	main()
{
	char	*alpha;

	alpha = "42BCN";
	printf("%ld \n",ft_strlen(alpha));
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putnbr_fd.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/13 10:04:06 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 11:10:02 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_putnbr_fd(int n, int fd)
{
	long	num;

	if (fd < 0)
		return ;
	num = n;
	if (num < 0)
	{
		ft_putchar_fd('-', fd);
		num = -num;
	}
	if (num >= 10)
		ft_putnbr_fd(num / 10, fd);
	ft_putchar_fd(num % 10 + '0', fd);
}
/*
int	main()
{
	int	number;

	number = 42;
	ft_putnbr_fd(number, 1);
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putendl_fd.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/13 10:03:29 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 11:05:40 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"
#include <unistd.h>

void	ft_putendl_fd(char *s, int fd)
{
	if (!s || fd <= 0)
		return ;
	ft_putstr_fd(s, fd);
	ft_putchar_fd('\n', fd);
}
/*
int	main()
{
	char	str1[] = "42 to teh Moon!";

	ft_putendl_fd(str1, 1);
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_striteri.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/13 10:01:01 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/19 08:19:24 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_striteri(char *s, void (*f)(unsigned int, char *))
{
	unsigned int	i;

	if (!s || !f)
		return ;
	i = 0;
	while (s[i])
	{
		f(i, &s[i]);
		i++;
	}
}
/*
#include <stdio.h>

void	funsion(unsigned int i, char *str)
{
	if (i % 2 == 0)
		*str = ft_toupper(*str);
	else
		*str = ft_tolower(*str);
}

int	main()
{
	char	str[] = "42 To the moon!";

	ft_striteri(str, funsion);
	printf("%s\n", str);
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isalpha.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/05 12:41:50 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/15 10:31:37 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_isalpha(int c)
{
	if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))
		return (1);
	else
		return (0);
}
/*
#include <stdio.h>

int	main()
{
	char	alpha;
	char	digit;
	char	alnum;
	char	print;

	alpha = 'a';
	digit = '1';
	alnum = 'a';
	print = '\n';
	printf("%d \n",ft_isalpha(alpha));
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strtrim.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/10 13:44:56 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 08:18:01 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_find_set(char c, const char *set)
{
	while (*set)
	{
		if (c == *set)
			return (1);
		set++;
	}
	return (0);
}

char	*ft_strtrim(char const *s1, char const *set)
{
	size_t	start;
	size_t	end;
	size_t	len;
	char	*result;

	if (!s1 || !set)
		return (NULL);
	start = 0;
	end = ft_strlen(s1);
	while (s1[start] != '\0' && ft_find_set(s1[start], set))
		start++;
	while (end > start && ft_find_set(s1[end - 1], set))
		end--;
	len = end - start;
	result = ft_calloc(len + 1, sizeof(char));
	if (!result)
		return (NULL);
	ft_strlcpy(result, s1 + start, len + 1);
	return (result);
}
/*
#include <stdio.h>

int	main()
{
	char	*str = "42BCN42";
	char	c	=	'4';

	
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_tolower.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/08 08:16:23 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/15 13:55:02 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_tolower(int c)
{
	if (c >= 65 && c <= 90)
		return (c + 32);
	return (c);
}
/*
#include <stdio.h>

int	main()
{
	char	letter;
	char	result;

	letter = 'A';
	result = ft_tolower(letter);
	printf("%c\n", result);
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strrchr.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/07 14:24:41 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 08:11:39 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_strrchr(const char *s, int c)
{
	int	i;

	i = 0;
	while (s[i])
		i++;
	while (i >= 0)
	{
		if (s[i] == (char)c)
			return ((char *)(s + i));
		i--;
	}
	return (NULL);
}
/*
#include <stdio.h>
int	main()
{
	char	frase[30] = "ABCDEFGHIJFK";
	int	letra = 'F';
	printf("%s\n",ft_strrchr(frase, letra));
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memcpy.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/07 10:18:33 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 07:55:34 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	*ft_memcpy(void *dest, const void *src, size_t n)
{
	size_t			i;
	unsigned char	*ptr_src;
	unsigned char	*ptr_dest;

	i = 0;
	ptr_src = (unsigned char *)src;
	ptr_dest = (unsigned char *)dest;
	if (!dest && !src)
		return (NULL);
	while (i < n)
	{
		ptr_dest[i] = ptr_src[i];
		i++;
	}
	return (dest);
}
/*
#include <stdio.h>

int	main()
{
	char	phrase[] = "42BCN to the Moon my Frate";
	char	dest[50];
	size_t	n;

	n = 5;
	ft_memcpy(dest, phrase, n);
	printf("%s\n", dest);
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_itoa.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/13 09:58:47 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/19 08:18:40 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

static int	ft_get_len(int n)
{
	int	len;

	len = 0;
	if (n <= 0)
		len = 1;
	while (n != 0)
	{
		len++;
		n /= 10;
	}
	return (len);
}

static void	ft_fill_str(char *str, int n, int len)
{
	if (n == 0)
		str[0] = '0';
	if (n < 0)
	{
		str[0] = '-';
		n = n * -1;
	}
	str[len] = '\0';
	while (n)
	{
		str[--len] = (n % 10) + '0';
		n = n / 10;
	}
}

char	*ft_itoa(int n)
{
	char	*str;
	int		len;

	if (n == -2147483648)
		return (ft_strdup("-2147483648"));
	len = ft_get_len(n);
	str = malloc(len + 1);
	if (!str)
		return (NULL);
	ft_fill_str(str, n, len);
	return (str);
}
/*
#include <stdio.h>

int	main()
{
	int	n = 42;

	printf("%s",ft_itoa(n));
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isprint.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/05 15:18:16 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/15 10:40:42 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_isprint(int c)
{
	if (c >= 32 && c <= 126)
		return (1);
	else
		return (0);
}
/*
#include <stdio.h>

int	main()
{
	char	alpha;
	char	digit;
	char	alnum;
	char	print;

	alpha = 'a';
	digit = '1';
	alnum = 'a';
	print = '\n';
	printf("%d \n",ft_isprint(print));
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_calloc.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/08 13:31:48 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/16 11:23:57 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	*ft_calloc(size_t nmemb, size_t size)
{
	void	*ptr;

	ptr = malloc(nmemb * size);
	if (!ptr)
		return (NULL);
	ft_bzero(ptr, nmemb * size);
	return (ptr);
}
/*
#include <stdio.h>

int	main()
{
	char	*str;

	str = (char *)ft_calloc(2, 4);
	str[0] = 'a';
	str[3] = 'b';
	printf("%s", str);
	return (0);	
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putchar_fd.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/13 10:02:01 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 11:08:52 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_putchar_fd(char c, int fd)
{
	if (fd < 0)
		return ;
	write(fd, &c, 1);
}
/*
int	main()
{
	char	letter;

	letter = 'A';
	ft_putchar_fd(letter, 1)
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strmapi.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/13 09:59:38 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/18 15:58:43 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_strmapi(char const *s, char (*f) (unsigned int, char))
{
	char	*str;
	size_t	len;
	size_t	i;

	if (!s || !f)
		return (NULL);
	len = ft_strlen(s);
	str = malloc (len + 1);
	if (!str)
		return (NULL);
	i = 0;
	while (s[i])
	{
		str[i] = f(i, s[i]);
		i++;
	}
	str[i] = '\0';
	return (str);
}
/*
#include <stdio.h>
 char    funsion(unsigned int valor, char letra)
 {
	if (valor % 2 == 0)
	letra = ft_toupper(letra);
	else
	letra = ft_tolower(letra);
	 return (letra);
}

int	main()
{
	char	str[] = "42 to the moon!";
	char	*result = ft_strmapi(str, funsion);

	printf("%s\n", result);
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_split.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/10 15:44:46 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 10:13:14 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

static int	ft_numofwrds(char const *s, char c)
{
	int	words_num;
	int	in_word;

	words_num = 0;
	in_word = 0;
	while (*s)
	{
		if (*s != c && !in_word)
		{
			in_word = 1;
			words_num++;
		}
		else if (*s == c)
			in_word = 0;
		s++;
	}
	return (words_num);
}

static char	*ft_cpywrd(const char *start, size_t len)
{
	char	*word;

	word = (char *)malloc(len + 1);
	if (!word)
		return (NULL);
	ft_strlcpy(word, start, len + 1);
	return (word);
}

static void	ft_free_mem(char **list, size_t until)
{
	size_t	i;

	i = 0;
	while (i < until)
	{
		free(list[i]);
		i++;
	}
	if (list)
		free (list);
}

static int	ft_extract_word(char const **s, char c, char **list, size_t *i)
{
	const char	*start;

	while (**s == c)
		(*s)++;
	start = *s;
	while (**s != c && **s != '\0')
		(*s)++;
	if (*s > start)
	{
		list[*i] = ft_cpywrd(start, *s - start);
		if (!list[*i])
			return (-1);
		(*i)++;
		return (1);
	}
	return (0);
}

char	**ft_split(char const *s, char c)
{
	char		**list;
	int			result;
	size_t		i;
	size_t		word_count;

	if (!s)
		return (NULL);
	word_count = ft_numofwrds(s, c);
	list = (char **)ft_calloc(word_count + 1, sizeof(char *));
	if (!list)
		return (NULL);
	i = 0;
	while (*s && i < word_count)
	{
		result = ft_extract_word(&s, c, list, &i);
		if (result == -1)
		{
			ft_free_mem(list, i);
			return (NULL);
		}
	}
	return (list);
}
/*
#include <stdio.h>

int	main()
{
    char *str = "42BCN to the Moon!";
    char **result = ft_split(str, ' ');
    size_t i = 0;

    if (!result)
        return (1);
    while (result[i])
    {
        printf("%s\n", result[i]);
        i++;
    }
    return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strjoin.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/09 16:36:02 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 08:17:08 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_strjoin(char const *s1, char const *s2)
{
	size_t	i;
	size_t	j;
	char	*s1s2;	

	if (!s1 || !s2)
		return (NULL);
	s1s2 = ft_calloc(ft_strlen(s1) + ft_strlen(s2) + 1, sizeof(char));
	if (!s1s2)
		return (NULL);
	i = 0;
	j = 0;
	while (s1[i])
	{
		s1s2[i] = s1[i];
		i++;
	}
	while (s2[j])
	{
		s1s2[i + j] = s2[j];
		j++;
	}
	return (s1s2);
}
/*
#include <stdio.h>

int	main()
{
	char	*str1 = "42BCN ";
	char	*str2 = "to the Moon!";

	printf("%s", ft_strjoin(str1, str2));
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strnstr.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/08 11:49:30 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/16 08:51:58 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

char	*ft_strnstr(const char *big, const char *little, size_t len)
{
	size_t	i;
	size_t	j;

	i = 0;
	if (*little == '\0')
		return ((char *)big);
	while (big[i] != '\0' && i < len)
	{
		j = 0;
		while (little[j] && big[i + j] == little[j] && i + j < len)
			j++;
		if (little[j] == '\0')
			return ((char *)big + i);
		i++;
	}
	return (NULL);
}
/*
#include <stdio.h>

int	main()
{
	char	*phrase1 = "42BCN to the moon";
	char	*phrase2 = "the moon";

	printf("%s\n", ft_strnstr(phrase1, phrase2, 20));
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlcat.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/08 09:17:56 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/15 13:29:12 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"
#include <stddef.h>

size_t	ft_strlcat(char *dst, const char *src, size_t size)
{
	size_t	i;
	size_t	j;

	i = 0;
	j = 0;
	while (dst[i] && i < size)
		i++;
	if (i == size)
		return (size + ft_strlen(src));
	while (src[j] && (i + j) < size - 1)
	{
		dst[i + j] = src[j];
		j++;
	}
	if (i + j < size)
		dst[i + j] = '\0';
	return (i + ft_strlen(src));
}
/*
#include <stdio.h>

int	main()
{
	size_t	result;
	char	phrase1[] = "42BCN";
	char	phrase2[] = " to the moon my frate!";
	result = ft_strlcat(phrase1, phrase2, 8);
	printf("%zu \n", result);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstsize_bonus.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/19 08:47:29 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 13:01:29 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

int	ft_lstsize(t_list *lst)
{
	size_t	i;

	i = 0;
	while (lst)
	{
		i++;
		lst = lst->next;
	}
	return ((int)i);
}
/*
#include <stdio.h>

int	main()
{
	char	*str1 = ft_strdup("42 ");
	char	*str2 = ft_strdup("to the Moon!");
	t_list	*lista = NULL;
	t_list	*nodo1 = ft_lstnew(str1);
	t_list	*nodo2 = ft_lstnew(str2);
	if (!nodo1 || !nodo2)
		return (1);
	ft_lstadd_back(&lista, nodo1);
	ft_lstadd_back(&lista, nodo2);
	t_list	*temp = lista;
	while (temp)
	{	
		printf("%s\n", (char *) temp->content);
		temp = temp->next;
	}
	printf("%d\n" ,ft_lstsize(lista));
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstlast_bonus.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/19 09:23:04 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 13:10:28 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

t_list	*ft_lstlast(t_list *lst)
{
	if (!lst)
		return (NULL);
	while (lst->next)
	{
		lst = lst->next;
	}
	return (lst);
}
/*
#include <stdio.h>

int	main()
{
	char	*str1 = ft_strdup("42 ");
	char	*str2 = ft_strdup("to the Moon!");
	t_list	*lista = NULL;
	t_list	*nodo1 = ft_lstnew(str1);
	t_list	*nodo2 = ft_lstnew(str2);
	if (!nodo1 || !nodo2)
		return (1);
	ft_lstadd_back(&lista, nodo1);
	ft_lstadd_back(&lista, nodo2);
	t_list	*temp = lista;
	while (temp)
	{	
		printf("%s\n", (char *) temp->content);
		temp = temp->next;
	}
	t_list	*last = ft_lstlast(lista);
	if (last)
		printf("ultimo nodo : %s\n", (char *)ultimo->content)
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstadd_back_bonus.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/19 09:38:52 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 13:24:25 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_lstadd_back(t_list **lst, t_list *new)
{
	t_list	*last;

	if (!lst || !new)
		return ;
	if (!*lst)
	{
		*lst = new;
		return ;
	}
	last = *lst;
	while (last->next)
		last = last->next;
	last->next = new;
}
/*
#include <stdio.h>

int	main()
{
	char	*str1 = ft_strdup("42 ");
	char	*str2 = ft_strdup("to the Moon!");
	t_list	*lista = NULL;
	t_list	*nodo1 = ft_lstnew(str1);
	t_list	*nodo2 = ft_lstnew(str2);
	if (!nodo1 || !nodo2)
		return (1);
	ft_lstadd_back(&lista, nodo1);
	ft_lstadd_back(&lista, nodo2);
	t_list	*temp = lista;
	while (temp)
	{	
		printf("%s\n", (char *) temp->content);
		temp = temp->next;
	}
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstdelone_bonus.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/19 10:44:24 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 12:38:05 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_lstdelone(t_list *lst, void (*del)(void*))
{
	if (!lst || !del)
		return ;
	del(lst->content);
	free(lst);
}
/*
#include <stdio.h>

void	del(void *content)
{
	free(content);
}

int	main()
{
	char	*str1 = ft_strdup("42 ");
	char	*str2 = ft_strdup("to the Moon!");
	t_list	*lista = NULL;
	t_list	*nodo1 = ft_lstnew(str1);
	t_list	*nodo2 = ft_lstnew(str2);
	if (!nodo1 || !nodo2)
		return (1);
	ft_lstadd_back(&lista, nodo1);
	ft_lstadd_back(&lista, nodo2);
	t_list	*temp = lista;
	while (temp)
	{	
		printf("%s\n", (char *) temp->content);
		temp = temp->next;
	}
	ft_lstdelone(nodo1, del);
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstclear_bonus.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/19 11:01:05 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 12:46:50 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_lstclear(t_list **lst, void (*del)(void *))
{
	t_list	*tmp;

	if (!lst || !*lst || !del)
		return ;
	while (*lst)
	{
		tmp = (*lst)->next;
		ft_lstdelone(*lst, del);
		*lst = tmp;
	}
	*lst = NULL;
}
/*
#include <stdio.h>

#include <stdio.h>

void	del(void *content)
{
	free(content);
}

int	main()
{
	char	*str1 = ft_strdup("42 ");
	char	*str2 = ft_strdup("to the Moon!");
	t_list	*lista = NULL;
	t_list	*nodo1 = ft_lstnew(str1);
	t_list	*nodo2 = ft_lstnew(str2);
	if (!nodo1 || !nodo2)
		return (1);
	ft_lstadd_back(&lista, nodo1);
	ft_lstadd_back(&lista, nodo2);
	t_list	*temp = lista;
	while (temp)
	{	
		printf("%s\n", (char *) temp->content);
		temp = temp->next;
	}
	ft_lstclear(&lista, del);
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstadd_front_bonus.c                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/19 08:42:21 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 11:31:12 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_lstadd_front(t_list **lst, t_list *new)
{
	new -> next = *lst;
	*lst = new;
}
/*
#include <stdio.h>

int	main()
{
	char	*str1 = "42 to ";
	char	*str2 = "the Moon!";
	t_list	nodo1;
	t_list	nodo2;
	t_list	lista = NULL;

	nodo1 = ft_lstnew(str1);
	nodo2 = ft_lstnew(str2);
	if (!nodo1 || !nodo2)
		return (1);

	ft_lstadd_front(&lista, nodo2);
	ft_lstadd_front(&lista, nodo1);
	while (lista)
	{
		printf("Conrtenido de nodo: %s\n", (char *)lista->content);
		lista = lista->next;
	}
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstnew_bonus.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/18 12:57:52 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 11:20:00 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

t_list	*ft_lstnew(void *content)
{
	t_list	*node;

	node = malloc(sizeof(t_list));
	if (!node)
		return (NULL);
	node->content = content;
	node->next = NULL;
	return (node);
}
/*
#include <stdio.h>

int	main()
{
	char	*str1 = "42 to the Moon!";
	t_list	*nodo1;

	nodo1 = ft_lstnew(str1);
	if (!nodo1)
	{
		printf("Error al crear el nodo!");
		return (1);
	}

	printf("El contenido es : %s\n", (char *)nodo1->content);
	printf("El next de este nodo es: %p\n", (void *) nodo1->next);
	free(nodo1);
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstiter_bonus.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/19 11:45:37 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 13:22:46 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

void	ft_lstiter(t_list *lst, void (*f)(void *))
{
	if (!lst || !f)
		return ;
	while (lst)
	{
		f(lst->content);
		lst = lst->next;
	}
}
/*
#include <stdio.h>

void	to_upper(void *content)
{
	char	*str = (char *)content;
	int	i = 0;
	while (str[i])
	{
		str[i] = ft_toupper(str[i]);
		i++;
	}
}

int	main()
{
	char	*str1 = ft_strdup("42 ");
	char	*str2 = ft_strdup("to the Moon!");
	t_list	*lista = NULL;
	t_list	*nodo1 = ft_lstnew(str1);
	t_list	*nodo2 = ft_lstnew(str2);
	if (!nodo1 || !nodo2)
		return (1);
	ft_lstadd_back(&lista, nodo1);
	ft_lstadd_back(&lista, nodo2);
	t_list	*temp = lista;
	while (temp)
	{	
		printf("%s\n", (char *) temp->content);
		temp = temp->next;
	}
	ft_lstiter(lista, to_upper;
	temp = lista;
	while (temp)
	{
		printf("%s\n", (char *)temp->content);
		temp = temp->next;
	}
	return (0);
}*/
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstmap_bonus.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: jadelgad <jadelgad@student.42barcelon      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/19 12:47:19 by jadelgad          #+#    #+#             */
/*   Updated: 2025/05/21 13:33:31 by jadelgad         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

t_list	*ft_lstmap(t_list *lst, void *(*f)(void *), void (*del)(void *))
{
	t_list	*new_list;
	t_list	*new_node;
	void	*new_content;

	new_list = NULL;
	while (lst)
	{
		new_content = f(lst->content);
		if (!new_content)
		{
			ft_lstclear(&new_list, del);
			return (NULL);
		}
		new_node = ft_lstnew(new_content);
		if (!new_node)
		{
			del(new_content);
			ft_lstclear(&new_list, del);
			return (NULL);
		}
		ft_lstadd_back(&new_list, new_node);
		lst = lst->next;
	}
	return (new_list);
}
/*
#include <stdio.h>

void *to_upper_copy(void *content)
{
    char	*str = (char *)content;
    char	*copy = ft_strdup(str);

    if (!copy)
        return (NULL);
    for (int i = 0; copy[i]; i++)
        copy[i] = ft_toupper(copy[i]);
    return (copy);
}

void del(void *content)
{
    free(content);
}

int	main()
{
	char	*str1 = ft_strdup("42 ");
	char	*str2 = ft_strdup("to the Moon!");
	t_list	*lista = NULL;
	t_list	*nodo1 = ft_lstnew(str1);
	t_list	*nodo2 = ft_lstnew(str2);
	if (!nodo1 || !nodo2)
		return (1);
	ft_lstadd_back(&lista, nodo1);
	ft_lstadd_back(&lista, nodo2);
	t_list	*temp = lista;
	while (temp)
	{	
		printf("%s\n", (char *) temp->content);
		temp = temp->next;
	}
	t_list	*newlst = list;
	if (!newlist)
	{
		ft_clearlst(&lista, del);
		return (1);
	}
	temp = newlist;
	while (temp)
	{
		printf("%s\n", temp->content)
		temp = temp->next;
	}
	return (0);
}*/
